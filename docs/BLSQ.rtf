{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \qc \f0 \sa180 \li0 \fi0 \b \fs36 Burleseque - Moonpage\par}
{\pard \qc \f0 \sa180 \li0 \fi0  Roman M\u252?ntener\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Contents\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ABOUT\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab HISTORY\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab SYNOPSIS\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab EXAMPLE USAGES\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab LANGUAGE\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab SYNTAX\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab BUILT-INS\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Abs {\f1 ab}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Add {\f1 .+}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab AddX {\f1 _+}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab And {\f1 &&}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Append {\f1 [+}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Average {\f1 av}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Average2 {\f1 AV}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Box {\f1 bx}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Concat {\f1 \\[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab ConcatMap {\f1 \\m}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Contains {\f1 ~[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Continuation {\f1 c!}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Decrement {\f1 -.}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Difference {\f1 \\\\}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Div {\f1 ./}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Duplicate {\f1 J} {\f1 ^^}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Equal {\f1 ==}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Eval {\f1 e!}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab EvalMany {\f1 E!}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Explode {\f1 XX}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Format {\f1 FF}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab FormatFromFormat {\f1 Ff}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab FromFormat {\f1 ff}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Greater {\f1 .>}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Group {\f1 =[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Head {\f1 -]}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab HeadTail {\f1 -~}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab IfElse {\f1 ie}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Iff {\f1 if}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Increment {\f1 +.}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab InfixOf {\f1 ~~}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Init {\f1 ~]}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab InitTail {\f1 ~-}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Intersection {\f1 IN}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Intersperse {\f1 [[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Last {\f1 [~}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Length {\f1 L[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Lines {\f1 ln}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Map {\f1 m[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Matches {\f1 ~=}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab MatchesList {\f1 =~}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Max {\f1 >.}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Maximum {\f1 >]}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Min {\f1 <.}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Minimum {\f1 <]}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Mod {\f1 .%}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Mul {\f1 .*}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab NotEqual {\f1 !=}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Nub {\f1 NB}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Or {\f1 ||}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PadLeft {\f1 P[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PadRight {\f1 [P}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Parse {\f1 ps}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Pop {\f1 vv}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Pow {\f1 **}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PrefixOf {\f1 ~!}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Prepend {\f1 +]}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Pretty {\f1 sh}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PrettyFormatFromFormat {\f1 SH}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PrettyFromFormat {\f1 Sh}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PrettyPretty {\f1 sH}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Product {\f1 pd}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab ProductMany {\f1 PD}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PushMany {\f1 ^p}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PushManyReverse {\f1 p^}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Range {\f1 r@}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab RangeInfinity {\f1 R@}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab ReadArray {\f1 ra}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab ReadDouble {\f1 rd}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab ReadInt {\f1 ri}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Reduce {\f1 r[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Replace {\f1 r~}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab ReplaceRegex {\f1 R~}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Reverse {\f1 <-}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Round {\f1 r_}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Round2 {\f1 R_}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Signum {\f1 sn}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Smaller {\f1 .<}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Sort {\f1 ><}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab SortReverse {\f1 <>}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Split {\f1 ;;}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab StripLeft {\f1 S[}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab StripRight {\f1 [S}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Sub {\f1 .-}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab SuffixOf {\f1 !~}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Sum {\f1 ++}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Swap {\f1 j} {\f1 \\/}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Tail {\f1 [-}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Union {\f1 UN}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Unlines {\f1 un}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab UnlinesPretty {\f1 uN}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Unparse {\f1 up}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab While {\f1 w!}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab WithLines {\f1 wl}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab WithLinesParsePretty {\f1 wL}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab WithLinesPretty {\f1 WL}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab WithWords {\f1 ww}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab WithWordsPretty {\f1 WW}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Xor {\f1 $$}\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 ABOUT\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An interpreter for the esoteric programming language {\i The Burlesque Programming Language}. Actually, Burlesque is less of a programming language than it is a tool. The actual language behind it is very simple and the only thing that makes Burlesque notable is the amount of built-ins it has. The syntax can be learnt within a few minutes (there are basically only Numbers, Strings and Blocks) and the concepts can be learnt quickly as well. People familiar with functional programming languages will already know these concepts so Burlesque is especially easy to learn if you already know the terms {\i map}, {\i filter}, {\i reduce}, {\i zip} and others. This moonpage tries to be as accurate, complete and easy to understand as possible. If you encounter an error in the documentation please report it on {\field{\*\fldinst{HYPERLINK "http://github.com/FMNSSun/Burlesque"}}{\fldrslt{\ul
github
}}}
. {\b Author:} Roman M\u252?ntener, 2012-?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Useful Weblinks:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "http://rosettacode.org/wiki/Category:Burlesque"}}{\fldrslt{\ul
Burlesque on RosettaCode
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "http://github.com/FMNSSun/Burlesque"}}{\fldrslt{\ul
Source code
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "http://mroman.ch/burlesque/lref.html"}}{\fldrslt{\ul
Language Reference
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Until this moonpage is complete please consult the Language Reference. Once compelete, the moonpage will superseed the Language Reference and this warning will disappear.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 HISTORY\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Burlesque has been under development since 2012 and is still being improved on a regular basis. It was built as a tool for me (mroman) to use as a helper for my computer science studies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 SYNOPSIS\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq \line
  --file <path>           Read code from file (incl. STDIN)\line
  --file-no-stdin <path>  Read code from file (excl. STDIN)\line
  --no-stdin <code>       Read code from argv (excl. STDIN)\line
  --shell                 Start in shell mode\line
  --version               Print version info\line
  --compile <path>        Pseudo-compile file to haskell code\line
  --stdin <code>          Read code from argv (incl. STDIN)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i path} - Path to a file\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i code} - Burlesque code\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i STDIN} will be pushed as a String to the stack. On exit all elements are printed in order from top to bottom. No output will be produced before the Burlesque code terminates.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 EXAMPLE USAGES\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ blsq --file-no-stdin hw.blsq \line
Hello, world!\line
$ echo -n "hello" | blsq --file revstdin.blsq \line
olleh\line
$ echo -n "hello" | blsq --stdin "<-Q"\line
olleh\line
$ blsq --no-stdin "2 64**"\line
18446744073709551616\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo -n `ls *.blsq` | blsq --stdin "wdzisp"\line
0 hw.blsq\line
1 index.blsq\line
2 prog.blsq\line
3 revstdin.blsq\line
4 test.blsq\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo -n `ls` | blsq --stdin 'wd\{".blsq"!~\}\{".blsq".-\}FMuN'\line
hw\line
index\line
prog\line
revstdin\line
test\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ df | blsq --stdin "ln[-\{WD-]\}muQ"\line
rootfs\line
udev\line
tmpfs\line
/dev/disk/by-uuid/2e7e48d9-b728-48f7-95db-a58db91f4769\line
tmpfs\line
tmpfs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 LANGUAGE\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 SYNTAX\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 BUILT-INS\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Abs {\f1 ab}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Absolute value of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -6ab\line
6\line
blsq ) 6ab\line
6\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Absolute value of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -6.0ab\line
6.0\line
blsq ) 6.0ab\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Add {\f1 .+}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer addition.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 5.+\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Double addition.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5.1 0.9.+\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Concatenates two strings.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab" "cd" .+\line
"abcd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, String b:} Returns the first {\f1 a} characters of {\f1 b} as a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3 "abcdef" .+\line
"abc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Concatenates two blocks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}\{3 4\}.+\line
\{1 2 3 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, Char b:} Creates a string with the two characters {\f1 a} and {\f1 b} in it (in that exact order).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a'b.+\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Append {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab"'c.+\line
"abc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Block b:} Returns the first {\f1 a} elements of {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2\{1 2 3\}.+\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b:} Returns the first {\f1 b} elements of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}2.+\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b:} Returns the first {\f1 b} characters of {\f1 a} as a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"2.+\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Convert {\f1 b} to Double, then perform addition.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1.0 2.+\line
3.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Double b:} Convert {\f1 a} to Double, then perform addition.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 1.0.+\line
3.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 AddX {\f1 _+}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Creates a Block with the two Integers {\f1 a} and {\f1 b} as elements (in this exact order).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2_+\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Creates a Block with the two Doubles {\f1 a} and {\f1 b} as elements (in this exact order).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1.0 2.0_+\line
\{1.0 2.0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Concatenates the two Strings.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab""cd"_+\line
"abcd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Concatenates the two Blocks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1\}\{2\}_+\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, Char b:} Converts both arguments two string and concatenates them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a'b_+\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Converts {\f1 b} to String, then concatenates.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "a"'b_+\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, String b:} Converts {\f1 a} to String, then appends it to {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a"b"_+\line
"ba"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, String b:} Converts {\f1 a} to String, then appends it to {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1"b"_+\line
"b1"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b:} Converts {\f1 b} to String, then concatenates.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "b"1_+\line
"b1"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 And {\f1 &&}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-zips if an argument provided is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Bitwise AND.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 4&&\line
0\line
blsq ) 1 7&&\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Append {\f1 [+}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Append {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}9[+\line
\{1 2 9\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Append {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab"'c[+\line
"abc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Concatenates Integers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 12 23[+\line
1223\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} This built-in is rather superfluous because most of its use-cases can be covered by either using {\f1 ++} or {\f1 _+}. Yet, there may be some rare use-cases where you might want to use it for example in {\f1 \{[+\}r[} or the like.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Average {\f1 av}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as:} {\i {\f1 J++jL[pd./}}. Calculates average.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}J++jL[pd./\line
2.5\line
blsq ) \{1 2 3 4\}av\line
2.5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} The {\f1 pd} is there to ensure that the result is always a Double.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Floor of {\f1 a} as Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5.9av\line
5\line
blsq ) 5.1av\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} If you want the floor of {\f1 a} as Double use {\f1 fo}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Average2 {\f1 AV}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 PDav}}. Calculates average.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3.2 4\}AV\line
2.75\line
blsq ) \{1 2 3.2 4\}av\line
2.55\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} This built-in is a relic from earlier versions of Burlesque where {\f1 ./} only worked on {\f1 Int, Int} or {\f1 Double, Double} but not with {\f1 Double, Int} or {\f1 Int, Double}. This meant that {\f1 av} could only be used on Blocks that contained Doubles (because {\f1 ++} would produce an Integer otherwise and the {\f1 L[pd./} would fail because an Integer could not be divided by a Double). In such cases {\f1 AV} had to be used. With newer versions the functionality of {\f1 ./} was extended and {\f1 av} can now be used on Blocks that contain Integers as well. However, if you use {\f1 AV} on a Block that contains Doubles it will convert all these Doubles to ceiling(a) which is not what you want in most cases. Thus: The use of {\f1 av} is recommended as it is safer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Box {\f1 bx}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a:} Puts {\f1 a} into a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5bx\line
\{5\}\line
blsq ) 'abx\line
\{'a\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Concat {\f1 \\[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} {\i Defined as:} {\i {\f1 \{\}}}. Empty Block becomes empty Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\}\\[\line
\{\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{Block (Char a)\}:} Return a single character string consisting of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{'a\}\\[\line
"a"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as:} {\i {\f1 \{_+\}r[}}. Concatenates elements in a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\{1 1\} \{2 1\} \{3\}\}\{_+\}r[\line
\{1 1 2 1 3\}\line
blsq ) \{\{1 1\} \{2 1\} \{3\}\}\\[\line
\{1 1 2 1 3\}\line
blsq ) \{'a 'b 'c\}\\[\line
"abc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} There is an additional special case when {\f1 \{_+\}r[} does not return a Block the return value will be boxed. Why this special case exist remains unknown.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ConcatMap {\f1 \\m}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 m[\\[}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{ro\}m[\\[\line
\{1 1 2 1 2 3\}\line
blsq ) \{1 2 3\}\{ro\}\\m\line
\{1 1 2 1 2 3\}\line
blsq ) \{1 2 3\}\{ro\}m[\line
\{\{1\} \{1 2\} \{1 2 3\}\}\line
blsq ) "abc"\{'ajr@\}\\m\line
"aababc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} The Map built-in detects if the input argument is a String and will concat automatically. Compare these examples:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"\{'ajr@\}m[\line
\{'a 'a 'b 'a 'b 'c\}\line
blsq ) "abc"XX\{'ajr@\}m[\line
\{\{'a\} \{'a 'b\} \{'a 'b 'c\}\}\line
blsq ) "abc"XX\{'ajr@\}\\m\line
\{'a 'a 'b 'a 'b 'c\}\line
blsq ) "abc"XX\{'ajr@\}\\m\\[\line
"aababc"\line
blsq ) "abc"\{'ajr@\}\\m\line
"aababc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Contains {\f1 ~[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Returns 1 if {\f1 a} contains {\f1 b} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}4~[\line
0\line
blsq ) \{1 2 3\}2~[\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Returns 1 if {\f1 a} contains {\f1 b} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"'b~[\line
1\line
blsq ) "abc"'z~[\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Returns 1 if {\f1 a} contains {\f1 b} otherwise returns 0 (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1223 22~[\line
1\line
blsq ) 1223 21~[\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Returns 1 if {\f1 a} contains {\f1 b} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello" "ell"~[\line
1\line
blsq ) "hello" "elo"~[\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Continuation {\f1 c!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Generally speaking a {\i Continuation} refers to executing code on a snapshot of the stack and then pushing the result back to the actual stack. This means that this built-in lets you run code without destroying data on the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Run {\f1 a} as a Continuation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 4.+\line
9\line
blsq ) 5 4\{.+\}c!\line
9\line
4\line
5\line
blsq ) 5 4\{.+J\}c!\line
9\line
4\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Decrement {\f1 -.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Decrements {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5-.\line
4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns the previous character (unicode point - 1)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'c-.\line
'b\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Prepend first character of {\f1 a} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"-.\line
"aabc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Prepend first element of {\f1 a} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}-.\line
\{1 1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Difference {\f1 \\\\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Notes:} If left argument contains duplicates as many of them will be removed as are in the right argument. Order is preserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Difference of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 1 1 2 3\}\{1 1\}\\\\\line
\{1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Difference of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcde""ce"\\\\\line
"abd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Difference of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1232 22\\\\\line
13\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Div {\f1 ./}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer division.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10 3./\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Double division.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10.0 3.0./\line
3.3333333333333335\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Removes {\f1 b} from the beginning of {\f1 a} iff {\f1 b} is a prefix of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "README.md" "README" ./\line
".md"\line
blsq ) "README.md" "REDME" ./\line
"README.md"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Removes {\f1 b} from the beginning of {\f1 a} iff {\f1 b} is a prefix of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{1 2\}./\line
\{3\}\line
blsq ) \{1 2 3\}\{2 2\}./\line
\{1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Double b:} Converts {\f1 a} to Double, then divides.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10 3.0./\line
3.3333333333333335\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Converts {\f1 b} to Double, then divides.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10.0 3./\line
3.3333333333333335\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Duplicate {\f1 J} {\f1 ^^}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Duplicates the top most element.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5\line
5\line
blsq ) 5J\line
5\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Equal {\f1 ==}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns 1 if {\f1 a == b} else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 5==\line
1\line
blsq ) 5.0 5==\line
0\line
blsq ) 3 2==\line
0\line
blsq ) \{1 23\}\{1 23\}==\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Eval {\f1 e!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Evaluates (executes) {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 5.+\}e!\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} If you want to eval a String use {\f1 pe}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 EvalMany {\f1 E!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 .*\\[e!}}. This built-in can be used to evaluate a Block a number of times.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1\{J.+\}1E!\line
2\line
blsq ) 1\{J.+\}2E!\line
4\line
blsq ) 1\{J.+\}3E!\line
8\line
blsq ) 1\{J.+\}4E!\line
16\line
blsq ) 1\{J.+\}4.*\\[e!\line
16\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Explode {\f1 XX}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Converts {\f1 a} to a Block of characters.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"XX\line
\{'a 'b 'c\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Converts {\f1 a} to a Block of digits (works on absolute value.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 971XX\line
\{9 7 1\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Converts {\f1 a} to a Block containing floor({\f1 a}) and ceiling({\f1 a}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5.3XX\line
\{5 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Converts to String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'aXX\line
"a"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} No operation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}XX\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} Sometimes this built-in is also referred to as {\i Xplode}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Format {\f1 FF}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Pretty a, Int format:} Change format of {\f1 a} to {\f1 format}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Formats are:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 0 - Normal\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 1 - No spaces\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 2 - With spaces\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 3 - Raw\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4 "5"\}\}sh0FF\line
[1, 2, [3, 4, "5"]]\line
blsq ) \{1 2 \{3 4 "5"\}\}sh1FF\line
[1,2,[3,4,"5"]]\line
blsq ) \{1 2 \{3 4 "5"\}\}sh2FF\line
[1 2 [3 4 "5"]]\line
blsq ) \{1 2 \{3 4 "5"\}\}sh3FF\line
\{1 2 \{3 4 "5"\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 FormatFromFormat {\f1 Ff}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 FFff}}. Generally just a shortcut for {\f1 FFff}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4\}\}sh2Ff\line
"[1 2 [3 4]]"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} In most cases you want to use {\f1 SH} directly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 FromFormat {\f1 ff}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Pretty a:} Converts the {\f1 a} to String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4\}\}shff\line
"[1, 2, [3, 4]]"\line
blsq ) \{1 2 \{3 4\}\}sh2FFff\line
"[1 2 [3 4]]"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Greater {\f1 .>}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns 1 if {\f1 a > b} else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3.0 2.9 .>\line
1\line
blsq ) 2.0 2.9 .>\line
0\line
blsq ) 10 5 .>\line
1\line
blsq ) 10 5.0 .>\line
0\line
blsq ) 'a 1 .>\line
1\line
blsq ) 'a 9.0 .>\line
1\line
blsq ) 'a \{\} .>\line
0\line
blsq ) \{\} 9.0 .>\line
1\line
blsq ) \{\} 9 .>\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Note:} Comparing values with different types may result in unexpected (but determinstic, thus not undefined) behaviour.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Group {\f1 =[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Groups together elements next to each other that are equal.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 2 3 4 4 5 6\}=[\line
\{\{1\} \{2 2\} \{3\} \{4 4\} \{5\} \{6\}\}\line
blsq ) \{1 2 2 3 4 4 4 6\}=[\line
\{\{1\} \{2 2\} \{3\} \{4 4 4\} \{6\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Groups together characters next to each other that are equal.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abbbbbc"=[\line
\{"a" "bbbbb" "c"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b See also:} {\i GroupBy}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Head {\f1 -]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns the first element of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{2 4 0\}-]\line
2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns the first character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"-]\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} If you need the first character of {\f1 a} as a String use {\f1 -~}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns the first digit of {\f1 a} (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -451-]\line
4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 HeadTail {\f1 -~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 -][-}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcd"-][-\line
"a"\line
blsq ) \{\{1 2 3\} \{4 5 6\}\}-~\line
\{2 3\}\line
blsq ) "abcd"-~\line
"a"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} Useful to get the first character of a String as a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 IfElse {\f1 ie}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b, Int a:} Executes {\f1 a} if b is not zero, otherwise executes {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5\{3.*\}\{2.*\}1ie\line
15\line
blsq ) 5\{3.*\}\{2.*\}0ie\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} This built-in is terrible because in most real-world cases it requires at least two additional swaps to get the result of a predicate to the top of the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Iff {\f1 if}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Block b:} Executes {\f1 b} only iff {\f1 a} is not zero.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 1\{3.*\}if\line
15\line
blsq ) 5 0\{3.*\}if\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b:} Executes {\f1 a} only iff {\f1 b} is not zero.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5\{3.*\}0if\line
5\line
blsq ) 5\{3.*\}1if\line
15\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Increment {\f1 +.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Increments a.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5+.\line
6\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns the next character (unicode point + 1).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a+.\line
'b\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Appends the last character of {\f1 a} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"+.\line
"abcc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Appends the last element of {\f1 a} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}+.\line
\{1 2 3 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 InfixOf {\f1 ~~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Returns 1 if {\f1 b} is an infix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{2 3\}~~\line
1\line
blsq ) \{1 2 3 4\}\{3 3\}~~\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} For Strings use {\f1 ~[}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Init {\f1 ~]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns all but the last elements of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}~]\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns all but the last character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "12a"~]\line
"12"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns all but the last digit of {\f1 a} (as Integer) (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 451~]\line
45\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 InitTail {\f1 ~-}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 ~][-}}. Can be used to remove the first and last element of a String/Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcd"~][-\line
"bc"\line
blsq ) "abcd"~-\line
"bc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Intersection {\f1 IN}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Notes:} Duplicates in the left argument are preserved. Order is preserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Intersection of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 1 1 2 2 2 2\} \{1 2 2 2 3 4 5\}IN\line
\{5 1 1 2 2 2 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Intersection of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc""dce"IN\line
"c"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Intersection of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 512 721IN\line
12\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Intersperse {\f1 [[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Block b:} Inserts {\f1 a} between elements in {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 0\{1 2 3\}[[\line
\{1 0 2 0 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, String b:} Inserts {\f1 a} between characters in {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'x"abc"[[\line
"axbxc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b See also:} {\i Intercalate}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Last {\f1 [~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns the last character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"[~\line
'c\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns the last element of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}[~\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns the last digit of {\f1 a} (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 451[~\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Length {\f1 L[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Number of characters in a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"L[\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Number of elements in a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}L[\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Converts to character based on unicode code point.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 69L[\line
'E\line
blsq ) 98L[\line
'b\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns case as either {\f1 'A} or {\f1 'a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'BL[\line
'A\line
blsq ) 'bL[\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lines {\f1 ln}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Split {\f1 a} into lines.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc\\ndef\\ngeh"ln\line
\{"abc" "def" "geh"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Number of digits in {\f1 a} (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 123ln\line
3\line
blsq ) -123ln\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Returns whichever is longer. If both are equal in length {\f1 b} is returned.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}\{1 2 3\}ln\line
\{1 2 3\}\line
blsq ) \{1 2 4\}\{1 2 3\}ln\line
\{1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b See also:} {\i WithLines}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Map {\f1 m[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Block f:} {\i Defined as:} {\i {\f1 jXXjm[\\[}}. Applies {\f1 f} to every character in {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "aBc"\{<-\}jXXjm[\\[\line
"AbC"\line
blsq ) "aBc"\{<-\}m[\line
"AbC"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block f:} Applies {\f1 f} to every element in {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4 5\}\{J.*\}m[\line
\{1 4 9 16 25\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b See also:} {\i ConcatMap} and there are many other different versions and shortcuts for {\i Map}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Matches {\f1 ~=}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String str, String regex:} Returns 1 if {\f1 regex} matches {\f1 str} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123""[0-3]\{3\}"~=\line
1\line
blsq ) "123""[1-3]\{3\}"~=\line
1\line
blsq ) "123""[1-3]\{4\}"~=\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 MatchesList {\f1 =~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String str, String regex:} Returns the capturing groups as a list. Empty block if no matches or no capture groups were used in the regular expression.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123abc""([0-3]\{3\}).(b.)"=~\line
\{"123" "bc"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Max {\f1 >.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns whichever is greatest.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 6>.\line
6\line
blsq ) 6 5>.\line
6\line
blsq ) \{12\}12>.\line
\{12\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Maximum {\f1 >]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns the maximum of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 2 1\}>]\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns the maximum of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "debca">]\line
'e\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns the largest digit as an Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1971>]\line
9\line
blsq ) 1671>]\line
7\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Min {\f1 <.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns whichever is smallest.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 4<.\line
4\line
blsq ) 5 4<.\line
4\line
blsq ) 10 10.0<.\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Minimum {\f1 <]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns the minimum of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 0 3\}<]\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns the minimum of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "bac"<]\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns the smallest digit as an Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 109<]\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Mod {\f1 .%}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is an auto-zip and auto-map built-in.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer modulo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10 3.%\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Mul {\f1 .*}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer multiplication.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 3.*\line
6\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Double multiplication.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2.0 3.0.*\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b:} Creates a Block containing {\f1 a} exactly {\f1 b} times.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab"3.*\line
\{"ab" "ab" "ab"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, Int b:} Creates a String containing {\f1 a} exactly {\f1 b} times.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a 3.*\line
"aaa"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b:} Creates a Block containing {\f1 a} exactly {\f1 b} times.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}3.*\line
\{\{1 2\} \{1 2\} \{1 2\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Appends {\f1 a} to {\f1 b} then reverses.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123""456".*\line
"321654"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Double b:} Converts {\f1 a} to Double, then multiplies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 3.0.*\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Converts {\f1 b} to Double, then multiplies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2.0 3.*\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 NotEqual {\f1 !=}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 ==n!}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 4 4==n!\line
0\line
blsq ) 4 3==n!\line
1\line
blsq ) 3 4==n!\line
1\line
blsq ) 3 4!=\line
1\line
blsq ) 4 4!=\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Nub {\f1 NB}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Nub means {\i removing duplicates}. Order is preserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Nub {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 1 1 2 2 2 2\}NB\line
\{5 1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Nub {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abccd"NB\line
"abcd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Nub {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 101010011NB\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Or {\f1 ||}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-zips if an argument provided is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Bitwise OR.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 4||\line
6\line
blsq ) 2 \{4 8\}||\line
\{6 10\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PadLeft {\f1 P[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b, Any c:} Pad {\f1 a} to length {\f1 b} by inserting {\f1 c} on the left (or removing elements from the right).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3 4 5\}4 1P[\line
\{1 3 4 5\}\line
blsq ) \{3 4 5 6 7\}4 1P[\line
\{3 4 5 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b, Char c:} Pad {\f1 a} to length {\f1 b} by inserting {\f1 c} on the left (or removing characters from the right).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "12"4' P[\line
"  12"\line
blsq ) "12345"4' P[\line
"1234"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PadRight {\f1 [P}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b, Any c:} Pad {\f1 a} to length {\f1 b} by inserting {\f1 c} on the right (or removing elements from the right).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3 4 5\}4 1[P\line
\{3 4 5 1\}\line
blsq ) \{3 4 5 6 7\}4 1[P\line
\{3 4 5 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b, Char c:} Pad {\f1 a} to length {\f1 b} by inserting {\f1 c} on the right (or removing characters from the right).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "12345"4' [P\line
"1234"\line
blsq ) "12"4' [P\line
"12  "\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Parse {\f1 ps}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if the argument given is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Tries to parse {\f1 a} with the Burlesque parser. (Tries to parse {\f1 a} as Burlesque code). Returns a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "5"ps\line
\{5\}\line
blsq ) "5 3.0.+"ps\line
\{5 3.0 .+\}\line
blsq ) "\{5 3.0.+\}m["ps\line
\{\{5 3.0 .+\} m[\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} This built-in is handy. Instead of doing something like:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "5 3 6 7"wdri++\line
21\par}
{\pard \ql \f0 \sa180 \li0 \fi0 you can just do:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "5 3 6 7"ps++\line
21\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pop {\f1 vv}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Removes the element on top of the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2\line
2\line
1\line
blsq ) 1 2vv\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} If there only is one element on top of the stack using {\f1 ,} is shorter.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pow {\f1 **}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Returns {\f1 a} to the power of {\f1 b} ({\f1 a ^ b}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 3**\line
8\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Returns {\f1 a} to the power of {\f1 b} ({\f1 a ^ b}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 4.0 3.0**\line
64.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Merges {\f1 a} and {\f1 b}. {\f1 c = a_1, b_1, a_2, b_2}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{4 5 6\}**\line
\{1 4 2 5 3 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Merges {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123""456"**\line
"142536"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns the unicode codepoint of {\f1 a} as an Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'A**\line
65\line
blsq ) 'a**\line
97\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PrefixOf {\f1 ~!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Returns 1 if {\f1 b} is a prefix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 4 3 2\}\{1 4\}~!\line
1\line
blsq ) \{1 4 3 2\}\{4 3\}~!\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Returns 1 if {\f1 b} is a prefix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "http://mroman.ch" "http://"~!\line
1\line
blsq ) "http://mroman.ch" "https://"~!\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Returns 1 if {\f1 b} is a prefix of {\f1 a} otherwise returns 0 (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1991 91~!\line
0\line
blsq ) 1991 199~!\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Prepend {\f1 +]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Prepend {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}3+]\line
\{3 1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Prepend {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab"'c+]\line
"cab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Prepends {\f1 b} to {\f1 a} (result is an Integer).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 12 23+]\line
2312\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pretty {\f1 sh}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a:} Convert to a Pretty with format {\i Normal}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc\\ndef"sh\line
abc\line
def\line
blsq ) \{1 2 3\}\line
\{1 2 3\}\line
blsq ) \{1 2 3\}sh\line
[1, 2, 3]\line
blsq ) 5.0\line
5.0\line
blsq ) 5.0sh\line
5.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PrettyFormatFromFormat {\f1 SH}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 jshjFf}}. Can be used to convert something to a String with a specified format.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4\}\}2SH\line
"[1 2 [3 4]]"\line
blsq ) \{1 2 \{3 4\}\}1SH\line
"[1,2,[3,4]]"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PrettyFromFormat {\f1 Sh}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 shff}}. Can be used to convert something to a String with format {\f1 Normal}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}Sh\line
"[1, 2, 3]"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PrettyPretty {\f1 sH}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 SHsh}}. Can be used to convert something for display with a specified format.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4\}\}1sH\line
[1,2,[3,4]]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Product {\f1 pd}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} {\i Defined as:} {\i {\f1 1}}. The product of an empty block is one.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as:} {\i {\f1 \{.*\}r[}}. Calculates the product of a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{.*\}r[\line
24\line
blsq ) \{1 2 3 4\}pd\line
24\line
blsq ) \{1 2 3.0 4\}pd\line
24.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} {\i Defined as:} {\i {\f1 Shrd}}. Converts to double.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5Shrd\line
5.0\line
blsq ) 5pd\line
5.0\line
blsq ) 5rd\line
5.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Ceiling of {\f1 a} as Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1.1pd\line
2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} If you want ceiling of {\f1 a} as Double use {\f1 cl}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ProductMany {\f1 PD}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 \{pd\}m[}}. Just maps {\f1 pd} over a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\{1 2 3\} 5 \{2 4\}\}\{pd\}m[\line
\{6 5.0 8\}\line
blsq ) \{\{1 2 3\} 5 \{2 4\}\}PD\line
\{6 5.0 8\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} Can be used as a shortcut for {\f1 )pd}. Otherwise this built-in doesn't offer too much over {\f1 rd} as {\f1 rd} auto-maps.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PushMany {\f1 ^p}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Pushes every element in {\f1 a} to the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a\{1 2 3\}^p\line
3\line
2\line
1\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PushManyReverse {\f1 p^}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Pushes every element in {\f1 a} to the stack in reversed order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a\{1 2 3\}p^\line
1\line
2\line
3\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Range {\f1 r@}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Generates a Block containing the numbers {\f1 a} through {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 10r@\line
\{1 2 3 4 5 6 7 8 9 10\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, Char b:} Generates a Block containing the characters {\f1 a} through {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a'zr@\line
\{'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't 'u 'v 'w 'x 'y 'z\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} Use {\i RangeConcat} if you need a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Square root of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 64.0r@\line
8.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns a Block with all permutations of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"r@\line
\{"abc" "bac" "cba" "bca" "cab" "acb"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns a Block with all permutations of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 0 9\}r@\line
\{\{1 0 9\} \{0 1 9\} \{9 0 1\} \{0 9 1\} \{9 1 0\} \{1 9 0\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 RangeInfinity {\f1 R@}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Str a:} All subsequences of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"R@\line
\{"" "a" "b" "ab" "c" "ac" "bc" "abc"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} All subsequences of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}R@\line
\{\{\} \{1\} \{2\} \{1 2\} \{3\} \{1 3\} \{2 3\} \{1 2 3\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Generates a Block containing the numbers {\f1 a} to Infinity.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5R@10.+\line
\{5 6 7 8 9 10 11 12 13 14\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ReadArray {\f1 ra}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if the argument given is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Parses an array in {\f1 [,]}-notation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "[1,2,3]"ra\line
\{1 2 3\}\line
blsq ) "[1,[2,4],3]"ra\line
\{1 \{2 4\} 3\}\line
blsq ) "[1,[2 4],3]"ra\line
\{1 \{2 4\} 3\}\line
blsq ) "[1,[2 4],,,,3]"ra\line
\{1 \{2 4\} 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It should be noted that {\f1 ,} are optional and multiple {\f1 ,} will be skipped as well. Nesting is supported.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns 1 iff {\f1 a} is space, else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) " \\t\\ra0"\{ra\}m[\line
\{1 1 1 0 0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ReadDouble {\f1 rd}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if the argument given is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Converts {\f1 a} to Double.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "3.0"rd\line
3.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} {\i Defined as:} {\i {\f1 pd}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} No operation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3.1rd\line
3.1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns 1 iff {\f1 a} is alpha, else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'ard\line
1\line
blsq ) '1rd\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} This built-in is useful to convert every element in a Block to a Double:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3.0 5 "3.14"\}rd\line
\{3.0 5.0 3.14\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ReadInt {\f1 ri}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if the argument given is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Converts {\f1 a} to Int.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "100"ri\line
100\line
blsq ) "-101"ri\line
-101\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} No operation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5ri\line
5\line
blsq ) -5ri\line
-5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} {\i Defined as:} {\i {\f1 av}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns 1 iff {\f1 a} is alpha numeric, else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'ari\line
1\line
blsq ) '1ri\line
1\line
blsq ) '.ri\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} This built-in is useful to convert every element in a Block to an Integer:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"12" 12.0 13 12.7\}ri\line
\{12 12 13 12\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, Doubles are not rounded to the nearest Integer but are truncated. Rounding everything to the nearest Integer can be done with for example {\f1 rd)R_}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Reduce {\f1 r[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block f:} Takes the first element of {\f1 a} and the second element of {\f1 a}, applies {\f1 f}, takes the next element of {\f1 a} and applies {\f1 f} again and continues like that. More symbolically speaking {\f1 \{1 2 3 4\}\{.+\}r[} becomes {\f1 1 2 .+ 3 .+ 4 .+}, {\f1 \{1 2 3 5\}\{?-\}r[} becomes {\f1 1 2 ?- 3 ?- 4?-} and so forth.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{.+\}r[\line
10\line
blsq ) \{1 2 3 4\}\{.*\}r[\line
24\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Replace {\f1 r~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b, Any c:} Replaces every occurence of {\f1 b} in {\f1 a} with {\f1 c}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 1 4\}1 9r~\line
\{9 2 3 9 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b, Char c:} Replaces every occurence of {\f1 b} in {\f1 a} with {\f1 c}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello"'l'!r~\line
"he!!o"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b, String c:} Replaces every occurence of {\f1 b} in {\f1 a} with {\f1 c}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hi there hi go""hi""bye"r~\line
"bye there bye go"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b, Int c:} Replaces every occurence of {\f1 b} in {\f1 a} with {\f1 c} (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -1334336 33 10r~\line
1104106\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ReplaceRegex {\f1 R~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String str, String repl, String regex:} Replaces every match of {\f1 regex} with {\f1 repl}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "Year 2014.""X""[[:digit:]]"R~\line
"Year XXXX."\line
blsq ) "Year 2014.""X""[0-3]"R~\line
"Year XXX4."\line
blsq ) "Year 2014.""__""[a-z]|[0-3]\{2\}"R~\line
"Y______ __14."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Reverse {\f1 <-}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Reverses {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123"<-\line
"321"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Reverses {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{4 5 6\}<-\line
\{6 5 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Reverses the digits of an Integer. (Works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -123<-\line
321\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Inverts case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a<-\line
'A\line
blsq ) 'B<-\line
'b\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Round {\f1 r_}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in accepts a Block as first argument, in which case an auto-map is performed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Rounds {\f1 a} to {\f1 b} decimal points.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3.12 2r_\line
3.12\line
blsq ) 3.19 2r_\line
3.19\line
blsq ) 3.5 0r_\line
4.0\line
blsq ) \{3.5 3.4\}0r_\line
\{4.0 3.0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Round2 {\f1 R_}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 0r_pd}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3.5 3.4\}0r_pd\line
12.0\line
blsq ) \{3.5 3.4\}R_\line
12.0\line
blsq ) 5.5R_\line
6\line
blsq ) 5.3R_\line
5\line
blsq ) 5.3 0r_pd\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} Even though {\f1 r_} can auto-map this built-in won't do the same {\i expected} job because {\f1 pd} will calculate the product of a Block. You may however use this fact as a shortcut for example for {\f1 \{0r_\}m[pd}. If you want to round every Double to the nearest Integer in a Block use {\f1 )R_}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Signum {\f1 sn}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Signum of {\f1 a}. (-1 for negative, 1 for positive, 0 for zero).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -6sn6sn0sn\line
0\line
1\line
-1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Signum of {\f1 a}. (-1.0 for negative, 1.0 for positive, 0.0 for zero).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -6.0sn6.0sn0.0sn\line
0.0\line
1.0\line
-1.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Smaller {\f1 .<}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns 1 if {\f1 a < b} else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 3.<\line
1\line
blsq ) 4 3.<\line
0\line
blsq ) \{1 2 3\}\{2 2 3\}.<\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Note:} Comparing values with different types may result in unexpected (but determinstic, thus not undefined) behaviour.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sort {\f1 ><}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Sorts {\f1 a} in ascending order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 3 4\}><\line
\{3 4 5\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Str a:} Sorts {\f1 a} in ascending order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "there"><\line
"eehrt"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Sorts {\f1 a} in ascending order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3241><\line
1234\line
blsq ) 32401><\line
1234\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Notes:} Please be aware that this will remove zeroes as numbers don't have leading zeroes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns {\f1 1} if {\f1 a} is a digit, {\f1 0} otherwise.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab10c")><\line
\{0 0 1 1 0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 SortReverse {\f1 <>}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 ><<-}}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 3 0 9 7 8\}<>\line
\{9 8 7 5 3 0\}\line
blsq ) \{5 3 0 9 7 8\}><<-\line
\{9 8 7 5 3 0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Split {\f1 ;;}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Split {\f1 a} on {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4 2 3 5 7 2 3 8\}\{2 3\};;\line
\{\{1\} \{4\} \{5 7\} \{8\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Split {\f1 a} on {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "Hello, world, is,"", ";;\line
\{"Hello" "world" "is,"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Split {\f1 a} on {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "Hello"'l;;\line
\{"He" "" "o"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, String b:} Split {\f1 b} on {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'e"Hello";;\line
\{"H" "llo"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Split {\f1 a} on {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1234256238 23;;\line
\{1 4256 8\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 StripLeft {\f1 S[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Removes any leading {\f1 b}s from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 1 2 5\}1S[\line
\{2 5\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Removes any leading {\f1 b}s from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "QQabQ"'QS[\line
"abQ"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns ({\f1 a} * {\f1 a}) (squares).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5S[\line
25\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} For Doubles use {\f1 fC}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 StripRight {\f1 [S}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Removes any trailing {\f1 b}s from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 0 0 0\}0[S\line
\{1\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Removes any trailing {\f1 b}s from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abccc"'c[S\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sub {\f1 .-}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer subtraction.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 5.-\line
-4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Double subtraction.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1.0 4.0.-\line
-3.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Removes {\f1 b} from the end of {\f1 a} iff {\f1 b} is a suffix of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "README.md" ".md".-\line
"README"\line
blsq ) "README.md" ".txt".-\line
"README.md"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Block b:} Removes the first {\f1 a} elements from {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3\{1 2 3 4\}.-\line
\{4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b:} Removes the first {\f1 b} characters from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcd"2.-\line
"cd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, String b:} Removes the first {\f1 a} characters from {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2"abcd".-\line
"cd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b:} Removes the first {\f1 b} elements from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}2.-\line
\{3 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Double b:} Converts {\f1 a} to Double, then subtracts.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 4 3.0.-\line
1.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Converts {\f1 b} to Double, then subtracts.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 4.0 3.-\line
1.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Removes {\f1 b} from the end of {\f1 a} iff {\f1 b} is a suffix of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{3 4\}.-\line
\{1 2\}\line
blsq ) \{1 2 3 4\}\{3 4 5\}.-\line
\{1 2 3 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 SuffixOf {\f1 !~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Returns 1 if {\f1 b} is a suffix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{2 3\}!~\line
1\line
blsq ) \{1 2 3\}\{1 2\}!~\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Returns 1 if {\f1 b} is a suffix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "this.txt" ".txt"!~\line
1\line
blsq ) "this.txt" ".pdf"!~\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Returns 1 if {\f1 b} is a suffix of {\f1 a} otherwise returns 0 (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 123 -23!~\line
1\line
blsq ) 123 -24!~\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sum {\f1 ++}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} {\i Defined as:} {\i {\f1 0}}. The sum of an empty Block is zero.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as:} {\i {\f1 \{.+\}r[}}. Calculates the sum of a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{.+\}r[\line
10\line
blsq ) \{1 2 3 4\}++\line
10\line
blsq ) \{1 2 3 4.0\}++\line
10.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Concatenates Integers (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 12 34++\line
1234\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Swap {\f1 j} {\f1 \\/}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Swaps the top two elements.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2\line
2\line
1\line
blsq ) 1 2j\line
1\line
2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Tail {\f1 [-}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns all but the first element of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}[-\line
\{2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns all but the first character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello"[-\line
"ello"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns all but the last digit of {\f1 a} (as Integer) (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 451[-\line
51\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Convert to string.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a[-\line
"a"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Union {\f1 UN}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Notes:} If left argument contains duplicates these will be preserved. Duplicates in the right argument will be removed. Order is preserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Union of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 1\} \{1 2 2 2 3\}UN\line
\{1 1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Union of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "zabc""cde"UN\line
"zabcde"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Union of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 12 14UN\line
124\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Unlines {\f1 un}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} If given an empty block returns an empty string.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\}un\line
""\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Otherwise:} {\i Defined as:} {\i {\f1 "\\n"j[[\\[}}. This is the {\i inverse} of {\f1 ln} and inserts newlines between elements.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"abc" "def" "ghe"\}"\\n"j[[\\[\line
"abc\\ndef\\nghe"\line
blsq ) \{"abc" "def" "ghe"\}un\line
"abc\\ndef\\nghe"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Notes:} Due to its definition this built-in will only work as expected when the Block contains Strings. If you want to {\i unlines} a Block containing other types use {\f1 Su}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}un\line
"\\n12\\n3"\line
blsq ) \{1 2 3\}Su\line
"1\\n2\\n3"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 UnlinesPretty {\f1 uN}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 unsh}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"12" "23"\}un\line
"12\\n23"\line
blsq ) \{"12" "23"\}uN\line
12\line
23\line
blsq ) \{"12" "23"\}unsh\line
12\line
23\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Unparse {\f1 up}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a:} Converts a to display string. This is somewhat the {\i inverse} of {\f1 ps}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2++\}up\line
"\{1 2 ++\}"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors' Note:} This built-in is somewhat equivalent to using {\f1 3SH}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 While {\f1 w!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A while-loop\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block f, Block p:} Executes {\f1 f} while {\f1 p} is not zero. {\f1 p} will be tested each time against the top of the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5\{+.\}\{10.<\}w!\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block f:} Executes {\f1 f} as long as the top of the stack is not zero. Same thing as doing {\f1 \{code\}\{\}w!}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 0 10\{j+.+.j-.\}w!\line
0\line
20\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithLines {\f1 wl}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 jlnjm[un}}. This built-in allows to map over the lines in a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc\\ndef"\{<-\}jlnjm[un\line
"cba\\nfed"\line
blsq ) "abc\\ndef"\{<-\}wl\line
"cba\\nfed"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithLinesParsePretty {\f1 wL}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 (ps)+]WL}}. This built-in allows to map over the lines in a String while calling {\i Parse} on each line automatically.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "11 22\\n5 6"\{++Sh\}(ps)+]WL\line
33\line
11\line
blsq ) "11 22\\n5 6"\{++Sh\}wL\line
33\line
11\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithLinesPretty {\f1 WL}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 wlsh}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc\\ndef"\{<-\}wlsh\line
cba\line
fed\line
blsq ) "abc\\ndef"\{<-\}WL\line
cba\line
fed\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithWords {\f1 ww}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as}: {\i {\f1 jWDjm[wd}}. This built-in allows to map over the words in a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello world"\{<-\}jWDjm[wd\line
"olleh dlrow"\line
blsq ) "hello world"\{<-\}ww\line
"olleh dlrow"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithWordsPretty {\f1 WW}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as}: {\i {\f1 wwsh}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello world"\{<-\}wwsh\line
olleh dlrow\line
blsq ) "hello world"\{<-\}WW\line
olleh dlrow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Xor {\f1 $$}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-zips if an argument provided is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Bitwise XOR.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 66 34$$\line
96\line
blsq ) 96 66 $$\line
34\line
blsq ) 96 34 $$\line
66\par}
}
