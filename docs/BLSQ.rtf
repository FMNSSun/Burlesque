{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \qc \f0 \sa180 \li0 \fi0 \b \fs36 Burleseque - Moonpage\par}
{\pard \qc \f0 \sa180 \li0 \fi0  Roman M\u252?ntener\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#about"}}{\fldrslt{\ul
ABOUT
}}}
\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\field{\*\fldinst{HYPERLINK "#history"}}{\fldrslt{\ul
HISTORY
}}}
\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#synopsis"}}{\fldrslt{\ul
SYNOPSIS
}}}
\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\field{\*\fldinst{HYPERLINK "#example-usages"}}{\fldrslt{\ul
EXAMPLE USAGES
}}}
\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#language"}}{\fldrslt{\ul
LANGUAGE
}}}
\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\field{\*\fldinst{HYPERLINK "#glossary"}}{\fldrslt{\ul
GLOSSARY
}}}
\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\field{\*\fldinst{HYPERLINK "#types"}}{\fldrslt{\ul
TYPES
}}}
\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\field{\*\fldinst{HYPERLINK "#syntax"}}{\fldrslt{\ul
SYNTAX
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#identifier"}}{\fldrslt{\ul
Identifier
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#specials"}}{\fldrslt{\ul
Specials
}}}
\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\field{\*\fldinst{HYPERLINK "#evaluation-model"}}{\fldrslt{\ul
Evaluation model
}}}
\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\field{\*\fldinst{HYPERLINK "#built-ins"}}{\fldrslt{\ul
BUILT-INS
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#abs-ab"}}{\fldrslt{\ul
Abs {\f1 ab}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#add-."}}{\fldrslt{\ul
Add {\f1 .+}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#addx-_"}}{\fldrslt{\ul
AddX {\f1 _+}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#and"}}{\fldrslt{\ul
And {\f1 &&}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#andls-r"}}{\fldrslt{\ul
AndLs {\f1 r&}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#append"}}{\fldrslt{\ul
Append {\f1 [+}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#average-av"}}{\fldrslt{\ul
Average {\f1 av}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#average2-av"}}{\fldrslt{\ul
Average2 {\f1 AV}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#blockaccess"}}{\fldrslt{\ul
BlockAccess {\f1 !!}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#box-bx"}}{\fldrslt{\ul
Box {\f1 bx}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#concat"}}{\fldrslt{\ul
Concat {\f1 \\[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#concatmap-m"}}{\fldrslt{\ul
ConcatMap {\f1 \\m}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#contains"}}{\fldrslt{\ul
Contains {\f1 ~[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#continuation-c"}}{\fldrslt{\ul
Continuation {\f1 c!}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#decrement--."}}{\fldrslt{\ul
Decrement {\f1 -.}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#difference"}}{\fldrslt{\ul
Difference {\f1 \\\\}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#div-."}}{\fldrslt{\ul
Div {\f1 ./}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#duplicate-j"}}{\fldrslt{\ul
Duplicate {\f1 J} {\f1 ^^}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#dupswap"}}{\fldrslt{\ul
DupSwap {\f1 ^/}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#equal"}}{\fldrslt{\ul
Equal {\f1 ==}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#eval-e"}}{\fldrslt{\ul
Eval {\f1 e!}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#evalmany-e"}}{\fldrslt{\ul
EvalMany {\f1 E!}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#explode-xx"}}{\fldrslt{\ul
Explode {\f1 XX}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#filter-f"}}{\fldrslt{\ul
Filter {\f1 f[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#findindex-fi"}}{\fldrslt{\ul
FindIndex {\f1 fi}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#findindexeq-fi"}}{\fldrslt{\ul
FindIndexEq {\f1 Fi}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#findindices-fi"}}{\fldrslt{\ul
FindIndices {\f1 fI}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#format-ff"}}{\fldrslt{\ul
Format {\f1 FF}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#formatfromformat-ff"}}{\fldrslt{\ul
FormatFromFormat {\f1 Ff}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#fromformat-ff"}}{\fldrslt{\ul
FromFormat {\f1 ff}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#greater-."}}{\fldrslt{\ul
Greater {\f1 .>}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#group"}}{\fldrslt{\ul
Group {\f1 =[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#head--"}}{\fldrslt{\ul
Head {\f1 -]}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#headtail--"}}{\fldrslt{\ul
HeadTail {\f1 -~}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#ifelse-ie"}}{\fldrslt{\ul
IfElse {\f1 ie}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#iff-if"}}{\fldrslt{\ul
Iff {\f1 if}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#increment-."}}{\fldrslt{\ul
Increment {\f1 +.}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#infixof"}}{\fldrslt{\ul
InfixOf {\f1 ~~}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#init"}}{\fldrslt{\ul
Init {\f1 ~]}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#inittail--"}}{\fldrslt{\ul
InitTail {\f1 ~-}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#intersection-in"}}{\fldrslt{\ul
Intersection {\f1 IN}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#intersperse"}}{\fldrslt{\ul
Intersperse {\f1 [[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#last"}}{\fldrslt{\ul
Last {\f1 [~}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#length-l"}}{\fldrslt{\ul
Length {\f1 L[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#lines-ln"}}{\fldrslt{\ul
Lines {\f1 ln}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#map-m"}}{\fldrslt{\ul
Map {\f1 m[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#mapdup-m"}}{\fldrslt{\ul
MapDup {\f1 [m}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#mapparse-m"}}{\fldrslt{\ul
MapParse {\f1 [M}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#mappretty-m"}}{\fldrslt{\ul
MapPretty {\f1 M[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#mapstring-m"}}{\fldrslt{\ul
MapString {\f1 ]m}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#maptopretty-m"}}{\fldrslt{\ul
MapToPretty {\f1 M]}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#maptoprettyfromformat-m"}}{\fldrslt{\ul
MapToPrettyFromFormat {\f1 m]}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#matches"}}{\fldrslt{\ul
Matches {\f1 ~=}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#matcheslist"}}{\fldrslt{\ul
MatchesList {\f1 =~}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#max-."}}{\fldrslt{\ul
Max {\f1 >.}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#maximum"}}{\fldrslt{\ul
Maximum {\f1 >]}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#min-."}}{\fldrslt{\ul
Min {\f1 <.}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#minimum"}}{\fldrslt{\ul
Minimum {\f1 <]}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#mod-."}}{\fldrslt{\ul
Mod {\f1 .%}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#mul-."}}{\fldrslt{\ul
Mul {\f1 .*}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#notequal"}}{\fldrslt{\ul
NotEqual {\f1 !=}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#nub-nb"}}{\fldrslt{\ul
Nub {\f1 NB}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#or"}}{\fldrslt{\ul
Or {\f1 ||}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#orls-r"}}{\fldrslt{\ul
OrLs {\f1 r|}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#padleft-p"}}{\fldrslt{\ul
PadLeft {\f1 P[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#padright-p"}}{\fldrslt{\ul
PadRight {\f1 [P}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#parse-ps"}}{\fldrslt{\ul
Parse {\f1 ps}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#pop-vv"}}{\fldrslt{\ul
Pop {\f1 vv}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#popswap-v"}}{\fldrslt{\ul
PopSwap {\f1 v/}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#pow"}}{\fldrslt{\ul
Pow {\f1 **}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#prefixof"}}{\fldrslt{\ul
PrefixOf {\f1 ~!}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#prepend"}}{\fldrslt{\ul
Prepend {\f1 +]}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#pretty-sh"}}{\fldrslt{\ul
Pretty {\f1 sh}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#prettyformatfromformat-sh"}}{\fldrslt{\ul
PrettyFormatFromFormat {\f1 SH}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#prettyfromformat-sh"}}{\fldrslt{\ul
PrettyFromFormat {\f1 Sh}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#prettypretty-sh"}}{\fldrslt{\ul
PrettyPretty {\f1 sH}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#product-pd"}}{\fldrslt{\ul
Product {\f1 pd}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#productmany-pd"}}{\fldrslt{\ul
ProductMany {\f1 PD}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#pushmany-p"}}{\fldrslt{\ul
PushMany {\f1 ^p}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#pushmanyreverse-p"}}{\fldrslt{\ul
PushManyReverse {\f1 p^}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#range-r"}}{\fldrslt{\ul
Range {\f1 r@}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#rangeinfinity-r"}}{\fldrslt{\ul
RangeInfinity {\f1 R@}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#readarray-ra"}}{\fldrslt{\ul
ReadArray {\f1 ra}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#readdouble-rd"}}{\fldrslt{\ul
ReadDouble {\f1 rd}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#readint-ri"}}{\fldrslt{\ul
ReadInt {\f1 ri}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#reduce-r"}}{\fldrslt{\ul
Reduce {\f1 r[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#replace-r"}}{\fldrslt{\ul
Replace {\f1 r~}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#replaceregex-r"}}{\fldrslt{\ul
ReplaceRegex {\f1 R~}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#reverse--"}}{\fldrslt{\ul
Reverse {\f1 <-}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#round-r_"}}{\fldrslt{\ul
Round {\f1 r_}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#round2-r_"}}{\fldrslt{\ul
Round2 {\f1 R_}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#signum-sn"}}{\fldrslt{\ul
Signum {\f1 sn}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#smaller-."}}{\fldrslt{\ul
Smaller {\f1 .<}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#sort"}}{\fldrslt{\ul
Sort {\f1 ><}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#sortreverse"}}{\fldrslt{\ul
SortReverse {\f1 <>}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#split"}}{\fldrslt{\ul
Split {\f1 ;;}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#stripleft-s"}}{\fldrslt{\ul
StripLeft {\f1 S[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#stripright-s"}}{\fldrslt{\ul
StripRight {\f1 [S}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#sub-.-"}}{\fldrslt{\ul
Sub {\f1 .-}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#suffixof"}}{\fldrslt{\ul
SuffixOf {\f1 !~}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#sum"}}{\fldrslt{\ul
Sum {\f1 ++}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#swap-j"}}{\fldrslt{\ul
Swap {\f1 j} {\f1 \\/}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#swapdup"}}{\fldrslt{\ul
SwapDup {\f1 /^}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#swappop-v"}}{\fldrslt{\ul
SwapPop {\f1 /v}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#tail--"}}{\fldrslt{\ul
Tail {\f1 [-}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#tolower-zz"}}{\fldrslt{\ul
ToLower {\f1 zz}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#toupper-zz"}}{\fldrslt{\ul
ToUpper {\f1 ZZ}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#union-un"}}{\fldrslt{\ul
Union {\f1 UN}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#unlines-un"}}{\fldrslt{\ul
Unlines {\f1 un}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#unlinespretty-un"}}{\fldrslt{\ul
UnlinesPretty {\f1 uN}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#unparse-up"}}{\fldrslt{\ul
Unparse {\f1 up}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#while-w"}}{\fldrslt{\ul
While {\f1 w!}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#withlines-wl"}}{\fldrslt{\ul
WithLines {\f1 wl}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#withlinesparsepretty-wl"}}{\fldrslt{\ul
WithLinesParsePretty {\f1 wL}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#withlinespretty-wl"}}{\fldrslt{\ul
WithLinesPretty {\f1 WL}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#withwords-ww"}}{\fldrslt{\ul
WithWords {\f1 ww}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#withwordspretty-ww"}}{\fldrslt{\ul
WithWordsPretty {\f1 WW}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#words-wd"}}{\fldrslt{\ul
Words {\f1 wd}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#words3-wd"}}{\fldrslt{\ul
Words3 {\f1 wD}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#xor"}}{\fldrslt{\ul
Xor {\f1 $$}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#zip-z"}}{\fldrslt{\ul
Zip {\f1 z[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#zipwith-z"}}{\fldrslt{\ul
ZipWith {\f1 Z[}
}}}
\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "#zipwithpush-z"}}{\fldrslt{\ul
ZipWithPush {\f1 Z]}
}}}
\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 ABOUT\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An interpreter for the esoteric programming language {\i The Burlesque Programming Language}. Actually, Burlesque is less of a programming language than it is a tool. The actual language behind it is very simple and the only thing that makes Burlesque notable is the amount of built-ins it has. The syntax can be learnt within a few minutes (there are basically only Numbers, Strings and Blocks) and the concepts can be learnt quickly as well. People familiar with functional programming languages will already know these concepts so Burlesque is especially easy to learn if you already know the terms {\i map}, {\i filter}, {\i reduce}, {\i zip} and others. This moonpage tries to be as accurate, complete and easy to understand as possible. If you encounter an error in the documentation please report it on {\field{\*\fldinst{HYPERLINK "http://github.com/FMNSSun/Burlesque"}}{\fldrslt{\ul
github
}}}
. {\b Author:} Roman M\u252?ntener, 2012-?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Useful Weblinks:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "http://rosettacode.org/wiki/Category:Burlesque"}}{\fldrslt{\ul
Burlesque on RosettaCode
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "http://github.com/FMNSSun/Burlesque"}}{\fldrslt{\ul
Source code
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "http://mroman.ch/burlesque/lref.html"}}{\fldrslt{\ul
Language Reference
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Until this moonpage is complete please consult the Language Reference. Once compelete, the moonpage will superseed the Language Reference and this warning will disappear.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 HISTORY\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Burlesque has been under development since 2012 and is still being improved on a regular basis. It was built as a tool for me (mroman) to use as a helper for my computer science studies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 SYNOPSIS\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq \line
  --file <path>           Read code from file (incl. STDIN)\line
  --file-no-stdin <path>  Read code from file (excl. STDIN)\line
  --no-stdin <code>       Read code from argv (excl. STDIN)\line
  --shell                 Start in shell mode\line
  --version               Print version info\line
  --compile <path>        Pseudo-compile file to haskell code\line
  --stdin <code>          Read code from argv (incl. STDIN)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i path} - Path to a file\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i code} - Burlesque code\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i STDIN} will be pushed as a String to the stack. On exit all elements are printed in order from top to bottom. No output will be produced before the Burlesque code terminates.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 EXAMPLE USAGES\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ blsq --file-no-stdin hw.blsq \line
Hello, world!\line
$ echo -n "hello" | blsq --file revstdin.blsq \line
olleh\line
$ echo -n "hello" | blsq --stdin "<-Q"\line
olleh\line
$ blsq --no-stdin "2 64**"\line
18446744073709551616\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo -n `ls *.blsq` | blsq --stdin "wdzisp"\line
0 hw.blsq\line
1 index.blsq\line
2 prog.blsq\line
3 revstdin.blsq\line
4 test.blsq\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo -n `ls` | blsq --stdin 'wd\{".blsq"!~\}\{".blsq".-\}FMuN'\line
hw\line
index\line
prog\line
revstdin\line
test\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ df | blsq --stdin "ln[-\{WD-]\}muQ"\line
rootfs\line
udev\line
tmpfs\line
/dev/disk/by-uuid/2e7e48d9-b728-48f7-95db-a58db91f4769\line
tmpfs\line
tmpfs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 LANGUAGE\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 GLOSSARY\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Block: A collection of values.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Identifier: An identifier. Refers to a Command.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Command: A unit of execution. A Command does something.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Built-in: A Command that is built-in. It\u8217's not a user defined Command.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Map: Other languages call this asociative array or dictionary.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Special: A special identifier.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Modifier: A Modifier is not a Command. A Modifier may modify the behaviour of the next Command or may alter evaluation.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 TYPES\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 SYNTAX\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The syntax of Burlesque is rather easy on one hand but incredibly complicated once one dives deeper into the rabbit hole. The basic syntax of Burlesque is rather easy.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Identifier\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An Identifier used to be exactly two characters long but this rule no longer applies. A built-in can have pretty much any number of characters. The rules for parsing Identifiers are incredibly complicated. Burlesque tries to parse Identifiers as a last option meaning if any other parsing rule matches it is not parsed as an Identifier. It\u8217's thus vital to know all the other parsing rules to be able to know when something is parsed as an identifier or not.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A two character Identifier must start with one of {\f1 1234567890\{\}'," ()yYV} and the second character can be anything. A single character built-in must start with one of {\f1 jJQ}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Two backticks can be used to parse an arbitrary length built-in. The two backticks aren\u8217't part of the parsed built-in. It parses until it sees a space or newline.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Specials\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A special is not a Command nor is it an Identifier. It is a Modifier that is evaluated at runtime. Currently the following specials exist: {\f1 ,}, {\f1 )}, {\f1 @}, {\f1 :}, and {\f1 %}. {\f1 #Q}, {\f1 #q}, {\f1 #J}, {\f1 #j} are technically modifiers as well but are parsed as Identifiers and have a runtime type of {\f1 Ident}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Evaluation model\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Burlesque is a lazy language. It only evaluates things when necessary. This enables one to use Blocks that are infinitely long. Burlesque has a primary stack and a secondary stack and a Map. These are passed from built-in to built-in. However, in sub-evaluations for example when using the map or filter builtins the primary stack changes during the sub-evaluation. In other words sub-evaluations run on their own primary stack - sometimes - not always. It depends on the built-in. The secondary stack and the Map remain accessible within sub-evaluations - sometimes - not always. It depends on the built-in. Burlesque evaluates from left to right. When a value is encountered it is pushed to the primary stack, when an Identifier is encountered the corresponding Command (built-in) will be executed. To push a Command to the stack use the quote syntax: {\f1 (++)} for example to push the Identifier {\f1 ++} to the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) (ab)to\line
"Ident"\line
blsq ) abto\line
"Error"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The Map is where variables are stored (the DB command pushes the Map to the primary stack and allows one to inspect it):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) %a=5 DB\line
<"a",5>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 BUILT-INS\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Abs {\f1 ab}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Absolute value of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -6ab\line
6\line
blsq ) 6ab\line
6\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Absolute value of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -6.0ab\line
6.0\line
blsq ) 6.0ab\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns {\f1 1} if {\f1 a} is a control else returns {\f1 0}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 0L[ab\line
1\line
blsq ) 32L[ab\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Add {\f1 .+}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer addition.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 5.+\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Double addition.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5.1 0.9.+\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Concatenates two strings.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab" "cd" .+\line
"abcd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, String b:} Returns the first {\f1 a} characters of {\f1 b} as a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3 "abcdef" .+\line
"abc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Concatenates two blocks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}\{3 4\}.+\line
\{1 2 3 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, Char b:} Creates a string with the two characters {\f1 a} and {\f1 b} in it (in that exact order).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a'b.+\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Append {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab"'c.+\line
"abc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Block b:} Returns the first {\f1 a} elements of {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2\{1 2 3\}.+\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b:} Returns the first {\f1 b} elements of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}2.+\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b:} Returns the first {\f1 b} characters of {\f1 a} as a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"2.+\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Convert {\f1 b} to Double, then perform addition.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1.0 2.+\line
3.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Double b:} Convert {\f1 a} to Double, then perform addition.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 1.0.+\line
3.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 AddX {\f1 _+}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Creates a Block with the two Integers {\f1 a} and {\f1 b} as elements (in this exact order).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2_+\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Creates a Block with the two Doubles {\f1 a} and {\f1 b} as elements (in this exact order).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1.0 2.0_+\line
\{1.0 2.0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Concatenates the two Strings.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab""cd"_+\line
"abcd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Concatenates the two Blocks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1\}\{2\}_+\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, Char b:} Converts both arguments two string and concatenates them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a'b_+\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Converts {\f1 b} to String, then concatenates.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "a"'b_+\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, String b:} Converts {\f1 a} to String, then appends it to {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a"b"_+\line
"ba"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, String b:} Converts {\f1 a} to String, then appends it to {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1"b"_+\line
"b1"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b:} Converts {\f1 b} to String, then concatenates.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "b"1_+\line
"b1"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 And {\f1 &&}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-zips if an argument provided is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Bitwise AND.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 4&&\line
0\line
blsq ) 1 7&&\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 AndLs {\f1 r&}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}}: If the top of the stack is an empty Block then this built-in will push a zero integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\}r&\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Otherwise}: {\i Defined as}: {\i {\f1 \{&&\}r[}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3 3 3\}r&\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Append {\f1 [+}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Append {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}9[+\line
\{1 2 9\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Append {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab"'c[+\line
"abc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Concatenates Integers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 12 23[+\line
1223\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} This built-in is rather superfluous because most of its use-cases can be covered by either using {\f1 ++} or {\f1 _+}. Yet, there may be some rare use-cases where you might want to use it for example in {\f1 \{[+\}r[} or the like.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Average {\f1 av}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as:} {\i {\f1 J++jL[pd./}}. Calculates average.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}J++jL[pd./\line
2.5\line
blsq ) \{1 2 3 4\}av\line
2.5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} The {\f1 pd} is there to ensure that the result is always a Double.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Floor of {\f1 a} as Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5.9av\line
5\line
blsq ) 5.1av\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} If you want the floor of {\f1 a} as Double use {\f1 fo}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Average2 {\f1 AV}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 PDav}}. Calculates average.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3.2 4\}AV\line
2.75\line
blsq ) \{1 2 3.2 4\}av\line
2.55\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} This built-in is a relic from earlier versions of Burlesque where {\f1 ./} only worked on {\f1 Int, Int} or {\f1 Double, Double} but not with {\f1 Double, Int} or {\f1 Int, Double}. This meant that {\f1 av} could only be used on Blocks that contained Doubles (because {\f1 ++} would produce an Integer otherwise and the {\f1 L[pd./} would fail because an Integer could not be divided by a Double). In such cases {\f1 AV} had to be used. With newer versions the functionality of {\f1 ./} was extended and {\f1 av} can now be used on Blocks that contain Integers as well. However, if you use {\f1 AV} on a Block that contains Doubles it will convert all these Doubles to ceiling(a) which is not what you want in most cases. Thus: The use of {\f1 av} is recommended as it is safer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 BlockAccess {\f1 !!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b}: Returns the {\f1 b}-th element of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}0!!\line
1\line
blsq ) \{1 2 3 4\}2!!\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b}: Returns the {\f1 b}-th character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}0!!\line
1\line
blsq ) \{1 2 3 4\}2!!\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Box {\f1 bx}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a:} Puts {\f1 a} into a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5bx\line
\{5\}\line
blsq ) 'abx\line
\{'a\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Concat {\f1 \\[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} {\i Defined as:} {\i {\f1 \{\}}}. Empty Block becomes empty Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\}\\[\line
\{\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{Block (Char a)\}:} Return a single character string consisting of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{'a\}\\[\line
"a"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as:} {\i {\f1 \{_+\}r[}}. Concatenates elements in a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\{1 1\} \{2 1\} \{3\}\}\{_+\}r[\line
\{1 1 2 1 3\}\line
blsq ) \{\{1 1\} \{2 1\} \{3\}\}\\[\line
\{1 1 2 1 3\}\line
blsq ) \{'a 'b 'c\}\\[\line
"abc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} There is an additional special case when {\f1 \{_+\}r[} does not return a Block the return value will be boxed. Why this special case exist remains unknown.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ConcatMap {\f1 \\m}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 m[\\[}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{ro\}m[\\[\line
\{1 1 2 1 2 3\}\line
blsq ) \{1 2 3\}\{ro\}\\m\line
\{1 1 2 1 2 3\}\line
blsq ) \{1 2 3\}\{ro\}m[\line
\{\{1\} \{1 2\} \{1 2 3\}\}\line
blsq ) "abc"\{'ajr@\}\\m\line
"aababc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} The Map built-in detects if the input argument is a String and will concat automatically. Compare these examples:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"\{'ajr@\}m[\line
\{'a 'a 'b 'a 'b 'c\}\line
blsq ) "abc"XX\{'ajr@\}m[\line
\{\{'a\} \{'a 'b\} \{'a 'b 'c\}\}\line
blsq ) "abc"XX\{'ajr@\}\\m\line
\{'a 'a 'b 'a 'b 'c\}\line
blsq ) "abc"XX\{'ajr@\}\\m\\[\line
"aababc"\line
blsq ) "abc"\{'ajr@\}\\m\line
"aababc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Contains {\f1 ~[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Returns 1 if {\f1 a} contains {\f1 b} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}4~[\line
0\line
blsq ) \{1 2 3\}2~[\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Returns 1 if {\f1 a} contains {\f1 b} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"'b~[\line
1\line
blsq ) "abc"'z~[\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Returns 1 if {\f1 a} contains {\f1 b} otherwise returns 0 (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1223 22~[\line
1\line
blsq ) 1223 21~[\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Returns 1 if {\f1 a} contains {\f1 b} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello" "ell"~[\line
1\line
blsq ) "hello" "elo"~[\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Continuation {\f1 c!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Generally speaking a {\i Continuation} refers to executing code on a snapshot of the stack and then pushing the result back to the actual stack. This means that this built-in lets you run code without destroying data on the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Run {\f1 a} as a Continuation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 4.+\line
9\line
blsq ) 5 4\{.+\}c!\line
9\line
4\line
5\line
blsq ) 5 4\{.+J\}c!\line
9\line
4\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Decrement {\f1 -.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Decrements {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5-.\line
4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns the previous character (unicode point - 1)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'c-.\line
'b\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Prepend first character of {\f1 a} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"-.\line
"aabc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Prepend first element of {\f1 a} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}-.\line
\{1 1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Difference {\f1 \\\\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Notes:} If left argument contains duplicates as many of them will be removed as are in the right argument. Order is preserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Difference of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 1 1 2 3\}\{1 1\}\\\\\line
\{1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Difference of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcde""ce"\\\\\line
"abd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Difference of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1232 22\\\\\line
13\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Div {\f1 ./}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer division.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10 3./\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Double division.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10.0 3.0./\line
3.3333333333333335\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Removes {\f1 b} from the beginning of {\f1 a} iff {\f1 b} is a prefix of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "README.md" "README" ./\line
".md"\line
blsq ) "README.md" "REDME" ./\line
"README.md"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Removes {\f1 b} from the beginning of {\f1 a} iff {\f1 b} is a prefix of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{1 2\}./\line
\{3\}\line
blsq ) \{1 2 3\}\{2 2\}./\line
\{1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Double b:} Converts {\f1 a} to Double, then divides.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10 3.0./\line
3.3333333333333335\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Converts {\f1 b} to Double, then divides.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10.0 3./\line
3.3333333333333335\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns {\f1 1} if {\f1 a} is a number else returns {\f1 0}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1634L[./\line
1\line
blsq ) '9./\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Duplicate {\f1 J} {\f1 ^^}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Duplicates the top most element.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5\line
5\line
blsq ) 5J\line
5\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 DupSwap {\f1 ^/}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 ^^\\/}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} Nobody has yet figured out what this is actually useful for. Some say it\u8217's useless, other\u8217's say\u8230? \u8216'Fuck you\u8217'.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Equal {\f1 ==}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns 1 if {\f1 a == b} else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 5==\line
1\line
blsq ) 5.0 5==\line
0\line
blsq ) 3 2==\line
0\line
blsq ) \{1 23\}\{1 23\}==\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Eval {\f1 e!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Evaluates (executes) {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 5.+\}e!\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} If you want to eval a String use {\f1 pe}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 EvalMany {\f1 E!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 .*\\[e!}}. This built-in can be used to evaluate a Block a number of times.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1\{J.+\}1E!\line
2\line
blsq ) 1\{J.+\}2E!\line
4\line
blsq ) 1\{J.+\}3E!\line
8\line
blsq ) 1\{J.+\}4E!\line
16\line
blsq ) 1\{J.+\}4.*\\[e!\line
16\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Explode {\f1 XX}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Converts {\f1 a} to a Block of characters.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"XX\line
\{'a 'b 'c\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Converts {\f1 a} to a Block of digits (works on absolute value.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 971XX\line
\{9 7 1\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Converts {\f1 a} to a Block containing floor({\f1 a}) and ceiling({\f1 a}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5.3XX\line
\{5 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Converts to String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'aXX\line
"a"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} No operation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}XX\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} Sometimes this built-in is also referred to as {\i Xplode}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Filter {\f1 f[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Block f:} {\i Somewhat defined as:} {\i {\f1 \\/XX\\/f[}}. Explodes the String to a Block of Chars before doing {\f1 f[}. This has a lot of special casing to simulate proper behaviour. The {\f1 f[} actually returns a Block of Chars which is then concatenated to form a proper String again.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcdehge"\{'e==\}f[\line
"ee"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block v, Block f:} Filters {\f1 f} using {\f1 v} as the condition. Filter removes all elements of the Block for which {\f1 v} returns false.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4 5 6\}\{2dv\}f[\line
\{2 4 6\}\line
blsq ) \{1 2 3 4 5 6\}\{3.>\}f[\line
\{4 5 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 FindIndex {\f1 fi}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block p}: Scans through the list (l2r) and returns the index of the first element where {\f1 p} evaluates to true.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4 5 6\}\{3==\}fi\line
2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Block p}: {\i Defined as}: {\i {\f1 \\/XX\\/fi}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcdef"\{'a!=\}fi\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 FindIndexEq {\f1 Fi}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any x}: Scans through the list (l2r) and returs the index of the first element equal to {\f1 x}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 3 9 10 2\}10Fi\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char x}: Scans through the list (l2r) and returns the index of the first element equal to {\f1 x}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcdef"'aFi\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 FindIndices {\f1 fI}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block p}: Scans through the list (l2r) and returns all indices of elements where {\f1 p} evaluates to true.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4 5 6 7 8\}\{2.%0==\}fI\line
\{1 3 5 7\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Block p}: {\i Defined as}: {\i {\f1 \\/XX\\/fI}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello"\{'l==\}fI\line
\{2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Format {\f1 FF}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Pretty a, Int format:} Change format of {\f1 a} to {\f1 format}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Formats are:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 0 - Normal\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 1 - No spaces\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 2 - With spaces\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 3 - Raw\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4 "5"\}\}sh0FF\line
[1, 2, [3, 4, "5"]]\line
blsq ) \{1 2 \{3 4 "5"\}\}sh1FF\line
[1,2,[3,4,"5"]]\line
blsq ) \{1 2 \{3 4 "5"\}\}sh2FF\line
[1 2 [3 4 "5"]]\line
blsq ) \{1 2 \{3 4 "5"\}\}sh3FF\line
\{1 2 \{3 4 "5"\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 FormatFromFormat {\f1 Ff}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 FFff}}. Generally just a shortcut for {\f1 FFff}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4\}\}sh2Ff\line
"[1 2 [3 4]]"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} In most cases you want to use {\f1 SH} directly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 FromFormat {\f1 ff}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Pretty a:} Converts the {\f1 a} to String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4\}\}shff\line
"[1, 2, [3, 4]]"\line
blsq ) \{1 2 \{3 4\}\}sh2FFff\line
"[1 2 [3 4]]"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Greater {\f1 .>}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns 1 if {\f1 a > b} else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3.0 2.9 .>\line
1\line
blsq ) 2.0 2.9 .>\line
0\line
blsq ) 10 5 .>\line
1\line
blsq ) 10 5.0 .>\line
0\line
blsq ) 'a 1 .>\line
1\line
blsq ) 'a 9.0 .>\line
1\line
blsq ) 'a \{\} .>\line
0\line
blsq ) \{\} 9.0 .>\line
1\line
blsq ) \{\} 9 .>\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Note:} Comparing values with different types may result in unexpected (but determinstic, thus not undefined) behaviour.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Group {\f1 =[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Groups together elements next to each other that are equal.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 2 3 4 4 5 6\}=[\line
\{\{1\} \{2 2\} \{3\} \{4 4\} \{5\} \{6\}\}\line
blsq ) \{1 2 2 3 4 4 4 6\}=[\line
\{\{1\} \{2 2\} \{3\} \{4 4 4\} \{6\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Groups together characters next to each other that are equal.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abbbbbc"=[\line
\{"a" "bbbbb" "c"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b See also:} {\i GroupBy}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Head {\f1 -]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns the first element of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{2 4 0\}-]\line
2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns the first character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"-]\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} If you need the first character of {\f1 a} as a String use {\f1 -~}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns the first digit of {\f1 a} (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -451-]\line
4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 HeadTail {\f1 -~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 -][-}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcd"-][-\line
"a"\line
blsq ) \{\{1 2 3\} \{4 5 6\}\}-~\line
\{2 3\}\line
blsq ) "abcd"-~\line
"a"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} Useful to get the first character of a String as a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 IfElse {\f1 ie}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b, Int a:} Executes {\f1 a} if b is not zero, otherwise executes {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5\{3.*\}\{2.*\}1ie\line
15\line
blsq ) 5\{3.*\}\{2.*\}0ie\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} This built-in is terrible because in most real-world cases it requires at least two additional swaps to get the result of a predicate to the top of the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Iff {\f1 if}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Block b:} Executes {\f1 b} only iff {\f1 a} is not zero.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 1\{3.*\}if\line
15\line
blsq ) 5 0\{3.*\}if\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b:} Executes {\f1 a} only iff {\f1 b} is not zero.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5\{3.*\}0if\line
5\line
blsq ) 5\{3.*\}1if\line
15\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Increment {\f1 +.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Increments a.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5+.\line
6\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns the next character (unicode point + 1).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a+.\line
'b\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Appends the last character of {\f1 a} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"+.\line
"abcc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Appends the last element of {\f1 a} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}+.\line
\{1 2 3 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 InfixOf {\f1 ~~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Returns 1 if {\f1 b} is an infix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{2 3\}~~\line
1\line
blsq ) \{1 2 3 4\}\{3 3\}~~\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} For Strings use {\f1 ~[}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Init {\f1 ~]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns all but the last elements of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}~]\line
\{1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns all but the last character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "12a"~]\line
"12"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns all but the last digit of {\f1 a} (as Integer) (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 451~]\line
45\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 InitTail {\f1 ~-}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 ~][-}}. Can be used to remove the first and last element of a String/Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcd"~][-\line
"bc"\line
blsq ) "abcd"~-\line
"bc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Intersection {\f1 IN}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Notes:} Duplicates in the left argument are preserved. Order is preserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Intersection of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 1 1 2 2 2 2\} \{1 2 2 2 3 4 5\}IN\line
\{5 1 1 2 2 2 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Intersection of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc""dce"IN\line
"c"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Intersection of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 512 721IN\line
12\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Intersperse {\f1 [[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Block b:} Inserts {\f1 a} between elements in {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 0\{1 2 3\}[[\line
\{1 0 2 0 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, String b:} Inserts {\f1 a} between characters in {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'x"abc"[[\line
"axbxc"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b See also:} {\i Intercalate}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Last {\f1 [~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns the last character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"[~\line
'c\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns the last element of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}[~\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns the last digit of {\f1 a} (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 451[~\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Length {\f1 L[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Number of characters in a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"L[\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Number of elements in a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}L[\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Converts to character based on unicode code point.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 69L[\line
'E\line
blsq ) 98L[\line
'b\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns case as either {\f1 'A} or {\f1 'a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'BL[\line
'A\line
blsq ) 'bL[\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lines {\f1 ln}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Split {\f1 a} into lines.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc\\ndef\\ngeh"ln\line
\{"abc" "def" "geh"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Number of digits in {\f1 a} (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 123ln\line
3\line
blsq ) -123ln\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Returns whichever is longer. If both are equal in length {\f1 b} is returned.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}\{1 2 3\}ln\line
\{1 2 3\}\line
blsq ) \{1 2 4\}\{1 2 3\}ln\line
\{1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns 1 if {\f1 a} is a printable character otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1L[ln\line
0\line
blsq ) 'aln\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b See also:} {\i WithLines}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Map {\f1 m[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Block f:} {\i Defined as:} {\i {\f1 jXXjm[\\[}}. Applies {\f1 f} to every character in {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "aBc"\{<-\}jXXjm[\\[\line
"AbC"\line
blsq ) "aBc"\{<-\}m[\line
"AbC"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block f:} Applies {\f1 f} to every element in {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4 5\}\{J.*\}m[\line
\{1 4 9 16 25\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b See also:} {\i ConcatMap} and there are many other different versions and shortcuts for {\i Map}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 MapDup {\f1 [m}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 (^^)+]m[}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{?*\}[m\line
\{1 4 9\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 MapParse {\f1 [M}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 (ps)+]m[}}. Can be used as a shortcut if the first step of the function that is being mapped over the Block is parsing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "5 6;7 8"';;;\{++\}[M\line
\{11 15\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 MapPretty {\f1 M[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 m[sh}}. Can be used as a shortcut if the result of mapping should be pretty printed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hi there"\{L[\}m[\line
"aaaaaaaa"\line
blsq ) "hi there"\{L[\}M[\line
aaaaaaaa\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 MapString {\f1 ]m}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 (Sh)[+m[}}. Can be used when one wants to apply a function to every element of a Block and each result should be converted to a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\{1 2 3\}\{4 5 6\}\}\{<-\}]m\line
\{"[3, 2, 1]" "[6, 5, 4]"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 MapToPretty {\f1 M]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 \{sh\}m[}}. Can be used as a shortcut to convert every element of a Block to Pretty.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hi there"wd\line
\{"hi" "there"\}\line
blsq ) "hi there"wdM]\line
\{hi there\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 MapToPrettyFromFormat {\f1 m]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 \{shff\}m[}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\{1 2 3\}\{4 5 6\}\}m]\line
\{"[1, 2, 3]" "[4, 5, 6]"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Matches {\f1 ~=}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String str, String regex:} Returns 1 if {\f1 regex} matches {\f1 str} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123""[0-3]\{3\}"~=\line
1\line
blsq ) "123""[1-3]\{3\}"~=\line
1\line
blsq ) "123""[1-3]\{4\}"~=\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 MatchesList {\f1 =~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String str, String regex:} Returns the capturing groups as a list. Empty block if no matches or no capture groups were used in the regular expression.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123abc""([0-3]\{3\}).(b.)"=~\line
\{"123" "bc"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Max {\f1 >.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns whichever is greatest.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 6>.\line
6\line
blsq ) 6 5>.\line
6\line
blsq ) \{12\}12>.\line
\{12\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Maximum {\f1 >]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns the maximum of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 2 1\}>]\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns the maximum of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "debca">]\line
'e\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns the largest digit as an Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1971>]\line
9\line
blsq ) 1671>]\line
7\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Min {\f1 <.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns whichever is smallest.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5 4<.\line
4\line
blsq ) 5 4<.\line
4\line
blsq ) 10 10.0<.\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Minimum {\f1 <]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns the minimum of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 0 3\}<]\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns the minimum of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "bac"<]\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns the smallest digit as an Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 109<]\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Mod {\f1 .%}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is an auto-zip and auto-map built-in.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer modulo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 10 3.%\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns {\f1 1} if {\f1 a} is punctuation otherwise returns {\f1 0}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) '..%\line
1\line
blsq ) 'a.%\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Mul {\f1 .*}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer multiplication.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 3.*\line
6\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Double multiplication.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2.0 3.0.*\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b:} Creates a Block containing {\f1 a} exactly {\f1 b} times.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab"3.*\line
\{"ab" "ab" "ab"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, Int b:} Creates a String containing {\f1 a} exactly {\f1 b} times.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a 3.*\line
"aaa"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b:} Creates a Block containing {\f1 a} exactly {\f1 b} times.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}3.*\line
\{\{1 2\} \{1 2\} \{1 2\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Appends {\f1 a} to {\f1 b} then reverses.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123""456".*\line
"321654"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Double b:} Converts {\f1 a} to Double, then multiplies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 3.0.*\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Converts {\f1 b} to Double, then multiplies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2.0 3.*\line
6.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns {\f1 1} if {\f1 a} is a symbol else returns {\f1 0}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) '9.*\line
0\line
blsq ) '+.*\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 NotEqual {\f1 !=}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 ==n!}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 4 4==n!\line
0\line
blsq ) 4 3==n!\line
1\line
blsq ) 3 4==n!\line
1\line
blsq ) 3 4!=\line
1\line
blsq ) 4 4!=\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Nub {\f1 NB}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Nub means {\i removing duplicates}. Order is preserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Nub {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 1 1 2 2 2 2\}NB\line
\{5 1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Nub {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abccd"NB\line
"abcd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Nub {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 101010011NB\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns {\f1 1} if {\f1 a} is lower case else returns {\f1 0}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'BNB\line
0\line
blsq ) 'bNB\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Or {\f1 ||}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-zips if an argument provided is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Bitwise OR.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 4||\line
6\line
blsq ) 2 \{4 8\}||\line
\{6 10\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 OrLs {\f1 r|}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}}: If the top of the stack is an empty Block then this built-in will push a zero integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\}r|\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Otherwise}: {\i Defined as}: {\i {\f1 \{||\}r[}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}r|\line
3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PadLeft {\f1 P[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b, Any c:} Pad {\f1 a} to length {\f1 b} by inserting {\f1 c} on the left (or removing elements from the right).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3 4 5\}4 1P[\line
\{1 3 4 5\}\line
blsq ) \{3 4 5 6 7\}4 1P[\line
\{3 4 5 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b, Char c:} Pad {\f1 a} to length {\f1 b} by inserting {\f1 c} on the left (or removing characters from the right).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "12"4' P[\line
"  12"\line
blsq ) "12345"4' P[\line
"1234"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PadRight {\f1 [P}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b, Any c:} Pad {\f1 a} to length {\f1 b} by inserting {\f1 c} on the right (or removing elements from the right).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3 4 5\}4 1[P\line
\{3 4 5 1\}\line
blsq ) \{3 4 5 6 7\}4 1[P\line
\{3 4 5 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b, Char c:} Pad {\f1 a} to length {\f1 b} by inserting {\f1 c} on the right (or removing characters from the right).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "12345"4' [P\line
"1234"\line
blsq ) "12"4' [P\line
"12  "\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Parse {\f1 ps}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if the argument given is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Tries to parse {\f1 a} with the Burlesque parser. (Tries to parse {\f1 a} as Burlesque code). Returns a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "5"ps\line
\{5\}\line
blsq ) "5 3.0.+"ps\line
\{5 3.0 .+\}\line
blsq ) "\{5 3.0.+\}m["ps\line
\{\{5 3.0 .+\} m[\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} This built-in is handy. Instead of doing something like:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "5 3 6 7"wdri++\line
21\par}
{\pard \ql \f0 \sa180 \li0 \fi0 you can just do:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "5 3 6 7"ps++\line
21\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pop {\f1 vv}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Removes the element on top of the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2\line
2\line
1\line
blsq ) 1 2vv\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} If there only is one element on top of the stack using {\f1 ,} is shorter.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PopSwap {\f1 v/}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 vv\\/}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2 3 4v/\line
2\line
3\line
1\line
blsq ) 1 2 3 4vv\\/\line
2\line
3\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pow {\f1 **}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Returns {\f1 a} to the power of {\f1 b} ({\f1 a ^ b}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 3**\line
8\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Returns {\f1 a} to the power of {\f1 b} ({\f1 a ^ b}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 4.0 3.0**\line
64.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Merges {\f1 a} and {\f1 b}. {\f1 c = a_1, b_1, a_2, b_2}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{4 5 6\}**\line
\{1 4 2 5 3 6\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Merges {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123""456"**\line
"142536"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns the unicode codepoint of {\f1 a} as an Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'A**\line
65\line
blsq ) 'a**\line
97\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PrefixOf {\f1 ~!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Returns 1 if {\f1 b} is a prefix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 4 3 2\}\{1 4\}~!\line
1\line
blsq ) \{1 4 3 2\}\{4 3\}~!\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Returns 1 if {\f1 b} is a prefix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "http://mroman.ch" "http://"~!\line
1\line
blsq ) "http://mroman.ch" "https://"~!\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Returns 1 if {\f1 b} is a prefix of {\f1 a} otherwise returns 0 (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1991 91~!\line
0\line
blsq ) 1991 199~!\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Prepend {\f1 +]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Prepend {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2\}3+]\line
\{3 1 2\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Prepend {\f1 b} to {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab"'c+]\line
"cab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Prepends {\f1 b} to {\f1 a} (result is an Integer).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 12 23+]\line
2312\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pretty {\f1 sh}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a:} Convert to a Pretty with format {\i Normal}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc\\ndef"sh\line
abc\line
def\line
blsq ) \{1 2 3\}\line
\{1 2 3\}\line
blsq ) \{1 2 3\}sh\line
[1, 2, 3]\line
blsq ) 5.0\line
5.0\line
blsq ) 5.0sh\line
5.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PrettyFormatFromFormat {\f1 SH}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 jshjFf}}. Can be used to convert something to a String with a specified format.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4\}\}2SH\line
"[1 2 [3 4]]"\line
blsq ) \{1 2 \{3 4\}\}1SH\line
"[1,2,[3,4]]"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PrettyFromFormat {\f1 Sh}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 shff}}. Can be used to convert something to a String with format {\f1 Normal}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}Sh\line
"[1, 2, 3]"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PrettyPretty {\f1 sH}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 SHsh}}. Can be used to convert something for display with a specified format.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 \{3 4\}\}1sH\line
[1,2,[3,4]]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Product {\f1 pd}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} {\i Defined as:} {\i {\f1 1}}. The product of an empty block is one.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as:} {\i {\f1 \{.*\}r[}}. Calculates the product of a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{.*\}r[\line
24\line
blsq ) \{1 2 3 4\}pd\line
24\line
blsq ) \{1 2 3.0 4\}pd\line
24.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} {\i Defined as:} {\i {\f1 Shrd}}. Converts to double.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5Shrd\line
5.0\line
blsq ) 5pd\line
5.0\line
blsq ) 5rd\line
5.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Ceiling of {\f1 a} as Integer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1.1pd\line
2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} If you want ceiling of {\f1 a} as Double use {\f1 cl}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ProductMany {\f1 PD}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 \{pd\}m[}}. Just maps {\f1 pd} over a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\{1 2 3\} 5 \{2 4\}\}\{pd\}m[\line
\{6 5.0 8\}\line
blsq ) \{\{1 2 3\} 5 \{2 4\}\}PD\line
\{6 5.0 8\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} Can be used as a shortcut for {\f1 )pd}. Otherwise this built-in doesn\u8217't offer too much over {\f1 rd} as {\f1 rd} auto-maps.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PushMany {\f1 ^p}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Pushes every element in {\f1 a} to the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a\{1 2 3\}^p\line
3\line
2\line
1\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PushManyReverse {\f1 p^}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Pushes every element in {\f1 a} to the stack in reversed order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a\{1 2 3\}p^\line
1\line
2\line
3\line
'a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Range {\f1 r@}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Generates a Block containing the numbers {\f1 a} through {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 10r@\line
\{1 2 3 4 5 6 7 8 9 10\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, Char b:} Generates a Block containing the characters {\f1 a} through {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a'zr@\line
\{'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't 'u 'v 'w 'x 'y 'z\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} Use {\i RangeConcat} if you need a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Square root of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 64.0r@\line
8.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns a Block with all permutations of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"r@\line
\{"abc" "bac" "cba" "bca" "cab" "acb"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns a Block with all permutations of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 0 9\}r@\line
\{\{1 0 9\} \{0 1 9\} \{9 0 1\} \{0 9 1\} \{9 1 0\} \{1 9 0\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 RangeInfinity {\f1 R@}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Str a:} All subsequences of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"R@\line
\{"" "a" "b" "ab" "c" "ac" "bc" "abc"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} All subsequences of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}R@\line
\{\{\} \{1\} \{2\} \{1 2\} \{3\} \{1 3\} \{2 3\} \{1 2 3\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Generates a Block containing the numbers {\f1 a} to Infinity.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5R@10.+\line
\{5 6 7 8 9 10 11 12 13 14\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ReadArray {\f1 ra}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if the argument given is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Parses an array in {\f1 [,]}-notation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "[1,2,3]"ra\line
\{1 2 3\}\line
blsq ) "[1,[2,4],3]"ra\line
\{1 \{2 4\} 3\}\line
blsq ) "[1,[2 4],3]"ra\line
\{1 \{2 4\} 3\}\line
blsq ) "[1,[2 4],,,,3]"ra\line
\{1 \{2 4\} 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It should be noted that {\f1 ,} are optional and multiple {\f1 ,} will be skipped as well. Nesting is supported.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns 1 iff {\f1 a} is space, else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) " \\t\\ra0"\{ra\}m[\line
\{1 1 1 0 0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ReadDouble {\f1 rd}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if the argument given is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Converts {\f1 a} to Double.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "3.0"rd\line
3.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} {\i Defined as:} {\i {\f1 pd}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} No operation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3.1rd\line
3.1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns 1 iff {\f1 a} is alpha, else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'ard\line
1\line
blsq ) '1rd\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} This built-in is useful to convert every element in a Block to a Double:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3.0 5 "3.14"\}rd\line
\{3.0 5.0 3.14\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ReadInt {\f1 ri}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if the argument given is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Converts {\f1 a} to Int.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "100"ri\line
100\line
blsq ) "-101"ri\line
-101\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} No operation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5ri\line
5\line
blsq ) -5ri\line
-5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} {\i Defined as:} {\i {\f1 av}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns 1 iff {\f1 a} is alpha numeric, else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'ari\line
1\line
blsq ) '1ri\line
1\line
blsq ) '.ri\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} This built-in is useful to convert every element in a Block to an Integer:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"12" 12.0 13 12.7\}ri\line
\{12 12 13 12\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, Doubles are not rounded to the nearest Integer but are truncated. Rounding everything to the nearest Integer can be done with for example {\f1 rd)R_}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Reduce {\f1 r[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block f:} Takes the first element of {\f1 a} and the second element of {\f1 a}, applies {\f1 f}, takes the next element of {\f1 a} and applies {\f1 f} again and continues like that. More symbolically speaking {\f1 \{1 2 3 4\}\{.+\}r[} becomes {\f1 1 2 .+ 3 .+ 4 .+}, {\f1 \{1 2 3 5\}\{?-\}r[} becomes {\f1 1 2 ?- 3 ?- 4?-} and so forth.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{.+\}r[\line
10\line
blsq ) \{1 2 3 4\}\{.*\}r[\line
24\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Replace {\f1 r~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b, Any c:} Replaces every occurence of {\f1 b} in {\f1 a} with {\f1 c}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 1 4\}1 9r~\line
\{9 2 3 9 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b, Char c:} Replaces every occurence of {\f1 b} in {\f1 a} with {\f1 c}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello"'l'!r~\line
"he!!o"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b, String c:} Replaces every occurence of {\f1 b} in {\f1 a} with {\f1 c}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hi there hi go""hi""bye"r~\line
"bye there bye go"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b, Int c:} Replaces every occurence of {\f1 b} in {\f1 a} with {\f1 c} (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -1334336 33 10r~\line
1104106\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ReplaceRegex {\f1 R~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String str, String repl, String regex:} Replaces every match of {\f1 regex} with {\f1 repl}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "Year 2014.""X""[[:digit:]]"R~\line
"Year XXXX."\line
blsq ) "Year 2014.""X""[0-3]"R~\line
"Year XXX4."\line
blsq ) "Year 2014.""__""[a-z]|[0-3]\{2\}"R~\line
"Y______ __14."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Reverse {\f1 <-}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Reverses {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "123"<-\line
"321"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Reverses {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{4 5 6\}<-\line
\{6 5 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Reverses the digits of an Integer. (Works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -123<-\line
321\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Inverts case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a<-\line
'A\line
blsq ) 'B<-\line
'b\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Round {\f1 r_}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in accepts a Block as first argument, in which case an auto-map is performed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Rounds {\f1 a} to {\f1 b} decimal points.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3.12 2r_\line
3.12\line
blsq ) 3.19 2r_\line
3.19\line
blsq ) 3.5 0r_\line
4.0\line
blsq ) \{3.5 3.4\}0r_\line
\{4.0 3.0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Round2 {\f1 R_}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 0r_pd}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{3.5 3.4\}0r_pd\line
12.0\line
blsq ) \{3.5 3.4\}R_\line
12.0\line
blsq ) 5.5R_\line
6\line
blsq ) 5.3R_\line
5\line
blsq ) 5.3 0r_pd\line
5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} Even though {\f1 r_} can auto-map this built-in won\u8217't do the same {\i expected} job because {\f1 pd} will calculate the product of a Block. You may however use this fact as a shortcut for example for {\f1 \{0r_\}m[pd}. If you want to round every Double to the nearest Integer in a Block use {\f1 )R_}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Signum {\f1 sn}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Signum of {\f1 a}. (-1 for negative, 1 for positive, 0 for zero).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -6sn6sn0sn\line
0\line
1\line
-1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a:} Signum of {\f1 a}. (-1.0 for negative, 1.0 for positive, 0.0 for zero).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) -6.0sn6.0sn0.0sn\line
0.0\line
1.0\line
-1.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns {\f1 1} if {\f1 a} is upper case else returns {\f1 0}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'Bsn\line
1\line
blsq ) 'bsn\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Smaller {\f1 .<}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b:} Returns 1 if {\f1 a < b} else returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2 3.<\line
1\line
blsq ) 4 3.<\line
0\line
blsq ) \{1 2 3\}\{2 2 3\}.<\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Note:} Comparing values with different types may result in unexpected (but determinstic, thus not undefined) behaviour.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sort {\f1 ><}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Sorts {\f1 a} in ascending order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 3 4\}><\line
\{3 4 5\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Str a:} Sorts {\f1 a} in ascending order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "there"><\line
"eehrt"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Sorts {\f1 a} in ascending order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3241><\line
1234\line
blsq ) 32401><\line
1234\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Notes:} Please be aware that this will remove zeroes as numbers don\u8217't have leading zeroes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Returns {\f1 1} if {\f1 a} is a digit, {\f1 0} otherwise.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "ab10c")><\line
\{0 0 1 1 0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 SortReverse {\f1 <>}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 ><<-}}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{5 3 0 9 7 8\}<>\line
\{9 8 7 5 3 0\}\line
blsq ) \{5 3 0 9 7 8\}><<-\line
\{9 8 7 5 3 0\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Split {\f1 ;;}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Split {\f1 a} on {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4 2 3 5 7 2 3 8\}\{2 3\};;\line
\{\{1\} \{4\} \{5 7\} \{8\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Split {\f1 a} on {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "Hello, world, is,"", ";;\line
\{"Hello" "world" "is,"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Split {\f1 a} on {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "Hello"'l;;\line
\{"He" "" "o"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a, String b:} Split {\f1 b} on {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'e"Hello";;\line
\{"H" "llo"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Split {\f1 a} on {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1234256238 23;;\line
\{1 4256 8\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 StripLeft {\f1 S[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Removes any leading {\f1 b}s from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 1 2 5\}1S[\line
\{2 5\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Removes any leading {\f1 b}s from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "QQabQ"'QS[\line
"abQ"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns ({\f1 a} * {\f1 a}) (squares).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5S[\line
25\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} For Doubles use {\f1 fC}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 StripRight {\f1 [S}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b:} Removes any trailing {\f1 b}s from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 0 0 0\}0[S\line
\{1\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Char b:} Removes any trailing {\f1 b}s from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abccc"'c[S\line
"ab"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sub {\f1 .-}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Integer subtraction.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 5.-\line
-4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Double b:} Double subtraction.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1.0 4.0.-\line
-3.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Removes {\f1 b} from the end of {\f1 a} iff {\f1 b} is a suffix of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "README.md" ".md".-\line
"README"\line
blsq ) "README.md" ".txt".-\line
"README.md"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Block b:} Removes the first {\f1 a} elements from {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 3\{1 2 3 4\}.-\line
\{4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Int b:} Removes the first {\f1 b} characters from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abcd"2.-\line
"cd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, String b:} Removes the first {\f1 a} characters from {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 2"abcd".-\line
"cd"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Int b:} Removes the first {\f1 b} elements from {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}2.-\line
\{3 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Double b:} Converts {\f1 a} to Double, then subtracts.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 4 3.0.-\line
1.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Double a, Int b:} Converts {\f1 b} to Double, then subtracts.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 4.0 3.-\line
1.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Removes {\f1 b} from the end of {\f1 a} iff {\f1 b} is a suffix of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{3 4\}.-\line
\{1 2\}\line
blsq ) \{1 2 3 4\}\{3 4 5\}.-\line
\{1 2 3 4\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 SuffixOf {\f1 !~}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Returns 1 if {\f1 b} is a suffix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{2 3\}!~\line
1\line
blsq ) \{1 2 3\}\{1 2\}!~\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Returns 1 if {\f1 b} is a suffix of {\f1 a} otherwise returns 0.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "this.txt" ".txt"!~\line
1\line
blsq ) "this.txt" ".pdf"!~\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Returns 1 if {\f1 b} is a suffix of {\f1 a} otherwise returns 0 (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 123 -23!~\line
1\line
blsq ) 123 -24!~\line
0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sum {\f1 ++}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} {\i Defined as:} {\i {\f1 0}}. The sum of an empty Block is zero.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as:} {\i {\f1 \{.+\}r[}}. Calculates the sum of a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3 4\}\{.+\}r[\line
10\line
blsq ) \{1 2 3 4\}++\line
10\line
blsq ) \{1 2 3 4.0\}++\line
10.0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Concatenates Integers (works on absolute values).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 12 34++\line
1234\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Swap {\f1 j} {\f1 \\/}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Swaps the top two elements.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2\line
2\line
1\line
blsq ) 1 2j\line
1\line
2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 SwapDup {\f1 /^}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} *{\f1 \\/^^}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2 3/^\line
2\line
2\line
3\line
1\line
blsq ) 1 2 3\\/^^\line
2\line
2\line
3\line
1\line
blsq ) 1 2 3/^\line
2\line
2\line
3\line
1\line
blsq ) 1 2 3jJ\line
2\line
2\line
3\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Author\u8217's Notes}: You might as well use {\f1 jJ}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 SwapPop {\f1 /v}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 \\/vv}}. This builtin essentially pops the element under the top of the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 1 2\line
2\line
1\line
blsq ) 1 2 /v\line
2\line
blsq ) 1 2 \\/vv\line
2\line
blsq ) 1 2 3 \\/vv\line
3\line
1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Tail {\f1 [-}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} Returns all but the first element of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}[-\line
\{2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a:} Returns all but the first character of {\f1 a}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello"[-\line
"ello"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a:} Returns all but the last digit of {\f1 a} (as Integer) (works on absolute value).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 451[-\line
51\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a:} Convert to string.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'a[-\line
"a"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ToLower {\f1 zz}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if an argument provided is a block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a}: Convert {\f1 a} to lower case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'Qzz\line
'q\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a}: Convert {\f1 a} to lower case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "aBc."zz\line
"abc."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ToUpper {\f1 ZZ}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-maps if an argument provided is a block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Char a}: Convert {\f1 a} to upper case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 'aZZ\line
'A\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a}: Convert {\f1 a} to upper case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "aBc."ZZ\line
"ABC."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Union {\f1 UN}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Notes:} If left argument contains duplicates these will be preserved. Duplicates in the right argument will be removed. Order is preserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Union of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 1\} \{1 2 2 2 3\}UN\line
\{1 1 2 3\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Union of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "zabc""cde"UN\line
"zabcde"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Union of {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 12 14UN\line
124\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Unlines {\f1 un}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} If given an empty block returns an empty string.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\}un\line
""\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Otherwise:} {\i Defined as:} {\i {\f1 "\\n"j[[\\[}}. This is the {\i inverse} of {\f1 ln} and inserts newlines between elements.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"abc" "def" "ghe"\}"\\n"j[[\\[\line
"abc\\ndef\\nghe"\line
blsq ) \{"abc" "def" "ghe"\}un\line
"abc\\ndef\\nghe"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} Due to its definition this built-in will only work as expected when the Block contains Strings. If you want to {\i unlines} a Block containing other types use {\f1 Su}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}un\line
"\\n12\\n3"\line
blsq ) \{1 2 3\}Su\line
"1\\n2\\n3"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 UnlinesPretty {\f1 uN}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 unsh}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"12" "23"\}un\line
"12\\n23"\line
blsq ) \{"12" "23"\}uN\line
12\line
23\line
blsq ) \{"12" "23"\}unsh\line
12\line
23\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Unparse {\f1 up}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a:} Converts a to display string. This is somewhat the {\i inverse} of {\f1 ps}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2++\}up\line
"\{1 2 ++\}"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Note:} This built-in is somewhat equivalent to using {\f1 3SH}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 While {\f1 w!}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A while-loop\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block f, Block p:} Executes {\f1 f} while {\f1 p} is not zero. {\f1 p} will be tested each time against the top of the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 5\{+.\}\{10.<\}w!\line
10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block f:} Executes {\f1 f} as long as the top of the stack is not zero. Same thing as doing {\f1 \{code\}\{\}w!}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 0 10\{j+.+.j-.\}w!\line
0\line
20\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithLines {\f1 wl}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 jlnjm[un}}. This built-in allows to map over the lines in a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc\\ndef"\{<-\}jlnjm[un\line
"cba\\nfed"\line
blsq ) "abc\\ndef"\{<-\}wl\line
"cba\\nfed"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithLinesParsePretty {\f1 wL}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 (ps)+]WL}}. This built-in allows to map over the lines in a String while calling {\i Parse} on each line automatically.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "11 22\\n5 6"\{++Sh\}(ps)+]WL\line
33\line
11\line
blsq ) "11 22\\n5 6"\{++Sh\}wL\line
33\line
11\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithLinesPretty {\f1 WL}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 wlsh}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc\\ndef"\{<-\}wlsh\line
cba\line
fed\line
blsq ) "abc\\ndef"\{<-\}WL\line
cba\line
fed\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithWords {\f1 ww}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as}: {\i {\f1 jWDjm[wd}}. This built-in allows to map over the words in a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello world"\{<-\}jWDjm[wd\line
"olleh dlrow"\line
blsq ) "hello world"\{<-\}ww\line
"olleh dlrow"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 WithWordsPretty {\f1 WW}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as}: {\i {\f1 wwsh}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hello world"\{<-\}wwsh\line
olleh dlrow\line
blsq ) "hello world"\{<-\}WW\line
olleh dlrow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Words {\f1 wd}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String _:} {\i Defined as:} {\i {\f1 " ";;}}. Splits by space.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "hi there"wd\line
\{"hi" "there"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block \{\}:} Pushes an empty string to the stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{\}wd\line
""\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a:} {\i Defined as}: {\i {\f1 ' \\/[[\\[}}. An {\i unwords}. It converts a Block of words into a String.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"hi" "there"\}wd\line
"hi there"\line
blsq ) \{"hi" "there"\}' \\/[[\\[\line
"hi there"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Otherwise:} {\i Defined as}: {\i {\f1 \\/[[}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"hi" "there" "you"\}'.wd\line
\{"hi" '. "there" '. "you"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} This built-in only splits by a regular space. If you want to split by whitespaces you need to use {\f1 WD} (Words2).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "a\\nb"wd\line
\{"a\\nb"\}\line
blsq ) "a\\nb"WD\line
\{"a" "b"\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Words3 {\f1 wD}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 wdsh}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{"abc" "def"\}wD\line
abc def\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Xor {\f1 $$}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This built-in auto-zips if an argument provided is a Block.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b:} Bitwise XOR.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 66 34$$\line
96\line
blsq ) 96 66 $$\line
34\line
blsq ) 96 34 $$\line
66\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Zip {\f1 z[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Block b:} Zips {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}\{4 5 6\}z[\line
\{\{1 4\} \{2 5\} \{3 6\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, String b:} Zips {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc""def"z[\line
\{\{'a 'd\} \{'b 'e\} \{'c 'f\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 String a, Block b:} Zips {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) "abc"\{1 2 3\}z[\line
\{\{'a 1\} \{'b 2\} \{'c 3\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, String b:} Zips {\f1 a} and {\f1 b}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) \{1 2 3\}"abc"z[\line
\{\{1 'a\} \{2 'b\} \{3 'c\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Int a, Int b}: {\i Defined as}: {\i {\f1 XX\\/XX\\/z[}}. (It\u8217'll explode the integers).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 blsq ) 123 456z[\line
\{\{1 4\} \{2 5\} \{3 6\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Block a, Any b}: {\i Defined as}: {\i {\f1 \\/XX\\/z[}}. (It\u8217'll explode argument {\f1 b}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Block b:}: {\i Defined as}: {\i {\f1 XXz[}}. (It\u8217'll explode argument {\f1 a}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ZipWith {\f1 Z[}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Any a, Any b, Block f}: Performs a {\i Zip} followed by a {\i Map}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ZipWithPush {\f1 Z]}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Defined as:} {\i {\f1 (^p+])Z[}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Authors\u8217' Notes:} This is was introduced to the fact that with the usual {\i ZipWith} the arguments are as a Block on the stack which is kinda inconvenient in most cases.\par}
}
