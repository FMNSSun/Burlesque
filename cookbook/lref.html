<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd" xml:lang="en"><head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<link href="style.css" rel="stylesheet" type="text/css">
    <title>Burlesque - Language reference</title>
  </head>
  <body>

<h1>Builtin Types</h1>
        <p>
          The following builtin types exist:
          <ul>
           <li>Int - Integer (UNBOUNDED!)</li>
           <li>Double - Double</li>
           <li>Str - String</li>
           <li>Char - Character</li>
           <li>Block - (Lists)</li>
           <li>Ident - Identifier</li>
           <li>Nil - Internal usage only</li>
           <li>Quoted - Can be used to push identifiers on the stack</li>
           <li>Error - Can not be written as a literal in code</li>
          </ul>
        </p>
        
        <h1 id="builtins">Builtins</h1>
<!-- -->
<table class="fancy">
<thead>
<tr><td>Name</td><td>Ident</td><td>Args</td><td>Description</td></tr>
</thead>
<tbody>
<tr><td>Abs</td><td>ab</td><td>Int a<br/>Double a</td><td>Abs a</td></tr>
<tr><td>Add</td><td>.+</td><td>Int a, Int b</td><td>Regular integer addition (a + b)</td></tr>
<tr><td></td><td>.+</td><td>Double a, Double b</td><td>Addition (a + b)</td></tr>
<tr><td></td><td>.+</td><td>Str a, Str b</td><td>String concatenation (a ++ b)</td></tr>
<tr><td></td><td>.+</td><td>Block a, Block b</td><td>Block concatenation (a ++ b)</td></tr>
<tr><td></td><td>.+</td><td>Char a, Char b</td><td>Append chars to form a string</td></tr>
<tr><td></td><td>.+</td><td>Str a, Char b</td><td>Append char to string</td></tr>
<tr><td></td><td>.+</td><td>Str a, Int b<br/>Block a, Int b</td><td>Take b characters from a</td></tr>
<tr><td>AddX</td><td>_+</td><td>Int a, Int b</td><td>Returns a block with a and b</td></tr>
<tr><td></td><td>_+</td><td>Double a, Double b</td><td>Returns a block with a and b</td></tr>
<tr><td></td><td>_+</td><td>Str a, Str b</td><td>String concatenation (a ++ b)</td></tr>
<tr><td></td><td>_+</td><td>Block a, Block b</td><td>Block concatenation (a ++ b)</td></tr>
<tr><td></td><td>_+</td><td>Char a, Char b</td><td>Append chars to form a string</td></tr>
<tr><td></td><td>_+</td><td>Str a, Char b<br>Char a, Str b</td><td>Append char to string</td></tr>
<tr><td></td><td>_+</td><td>Str a, Int b<br>Int a, Str b</td><td>Append int to string</td></tr>
<tr><td></td><td>_+</td><TD>Block a, Any b</td><td>Append b to a</td></str>
<tr><td>And</td><td>&amp;&amp;</td><td>Int a, Int b</td><td>Bitwise and</td></tr>
<tr><td>AndLs</td><td>r&amp;</td><td></td><td>Defined as {&amp;&amp;}r[</td></tr>
<tr><td>Append</td><td>[+</td><td>Block  a, Any b<br/>Int a, Int b</td><td>Append b to a</td></tr>
<tr><td></td><td>[+</td><td>Str a,Char b</td><td>Append b to a</td></tr>
<tr class="vnext"><td>Average</td><td>av</td><td>Block a</td><td>Defined as ^^ ++ \/ L[ pd ./</td></tr>
<tr class="vnext"><td></td><td>av</td><td>Double a</td><td>Floor a</td></tr>
<tr><td>BlockAccess</td><td>!!</td><td>Block a, Int n<br/>Str a, Int n</td><td>Return the nth element</td></tr>
<tr><td>Box</td><td>bx</td><td>Any a</td><td>Put a in an empty block</td></tr>
<tr><td>ChunksOf</td><td>co</td><td>Block a, Int n<br/>Str a, Int n<br/>Int a, Int n</td><td>Split a into chunks of size n</td></tr>
<tr><td>Chunky</td><td>CO</td><td>Block a, Int n<br/>Str a, Int n<br/>Int a, Int n</td><td>Create n-grams. "abc"2CO is {"ab" "bc"}</td></tr>
<tr><td>Concat</td><td></td><td>a</td><td>Defined as {.+}r[</td></tr>
<tr><td>ConcatMap</td><td>\m</td><td></td><td>Defined as m[\[</td></tr>
<tr><td>Contains</td><td>~[</td><td>Block a, Any b</td><td>Does a contain b?</td><tr>
<tr><td></td><td>~[</td><td>Str a, Char b</td><td>Does a contain b?</td></tr>
<tr><td></td><td>~[</td><td>Int a, Int b</td><td>Does a contain the digits of b?</td><tr>
<tr><td></td><td>~[</td><td>Str a, Str b</td><td>Does a contain b?</td></tr>
<tr><td>Continuation</td><td>c!</td><td>Block a</td><td>Continuation with a</td></tr>
<tr><td>Combinations</t><td>CB</td><td>Block a, Int n<br/>Str a, Int n</br>Int a, Int n</td><td>Generate a list of combinations of a of length n</td></tr>
<tr><td>CombinationsUpTo</td><td>cb</td><td>Block a, Int n<br/>Str a, Int n</br>Int a, Int n</td><td>Generate a list of combinations of a up to length n</td></tr>
<tr><td>Cycle</td><td>cy</td><td>Block a<br/>Str a</br></td><td>Repeat a infinite times</td></tr>
<tr><td>Decrement</td><td>-.</td><td>Int a</td><td>Decrement a--</td></tr>
<tr><td></td><td>-.</td><td>Char a</td><td>Previous char (chr(ord(a)-1))</td></tr>
<tr><td></td><td>-.</td><td>Str a<br/>Block a</td><td>Prepend head of a to a</td></tr>
<tr><td>DiffLs</td><td>\\</td><td>Block a, Block b<br/>Str a,Str b<br/>Int a, Int b</td><td>List difference (a \\ b)</td></tr>
<tr><td>Div</td><td>./</td><td>Int a, Int b</td><td>Regular integer division (a / b)</td></tr>
<tr><td></td><td>./</td><td>Double a, Double b</td><td>Division (a / b)</td></tr>
<tr><td>Dup</td><td>^^</td><td></td><td>Duplicate top most element on the stack</td></tr>
<tr><td>DupSwap</td><td>^/</td><td></td><td>Defined as ^^ \/</td></tr>
<tr><td>Equal</td><td>==</td><td>Any a, Any b</td><td>Comparision (a == b)</td></tr>
<tr><td>Eval</td><td>e!</td><td>Block a</td><td>Eval a block</td></tr>
<tr><td>EvalMany</td><td>E!</td><td></td><td>Defined as .*\[e!</td></tr>
<tr><td>Factors</td><td>fc</td><td>Int a</td><td>Return a block with every number a is divisible by</td></tr>
<tr><td></td><td>fc</td><td>Str a<br>Block a</td><td>Least common element</td></tr>
<tr><td>Filter</td><td>f[</td><td>Block f, Str a<br>Block f, Block a</td><td>Filters a list according to the predicate f (must return 1 or 0)</td></tr>
<tr><td>FindIndex</td><td>fi</td><td>Block a, Block f<br/>Str a, Block f</td><td>Find index of element where f returns true.</td></tr>
<tr><td>FindIndexEq</td><td>Fi</td><td>Block a, Any p<br/>Str a, Char p</td><td>Find index of an element equal to p</td></tr>
<tr class="vnext"><td>FindIndices</td><td>fI</td><td>Block a, Block f<br/>Str a, Block f</td><td>Like FindIndex but does not stop on the first match but instead returns a list of indices.</td></tr>
<tr><td>FindElement</td><td>fe</td><td>Block a, Block f<br/>Str a, Block f</td><td>Find an element where f is true and return it</td></tr>
<tr><td>Format</td><td>FF</td><td>Pretty a, Int b</td><td>Changes the format of a according to b</td></tr>
<tr><td>FormatFromFormat</td><td>Ff</td><td>n/a</td><td>Defined as FF ff</td></tr>
<tr><td>FromFormat</td><td>ff</td><td>Pretty a</td><td>Extracts the string out of the pretty</td></tr>
<tr><td>Greater</td><td>.&gt;</td><td>Any a, Any b</td><td>Comparision (a &gt; b)</td></tr>
<tr><td>Group</td><td>=[</td><td>Block a</td><td>Group (equal consecutive) elements in a</td></tr>
<tr><td>Head</td><td>-]</td><td>Block a<br/>Int a</td><td>First element</td></tr>
<tr><td></td><td>-]</td><td>Str a</td><td>First character</td></tr>
<tr><td>HeadTail</td><td>-~</td><td></td><td>Defined as -][-</td></tr>
<tr><td>IsError</t><td>is</td><td></td><td>Return 1 on error 0 else</td></tr>
<tr><td>IfElse</td><td>ie</td><td>Block a, Block b, Int c</td><td>If c then a else b</td></tr>
<tr><td>Iff</td><td>if</td><td>Block b, Int a</td><td>If a then execute b, else pop a and pop b</td></tr>
<tr><td>Increment</td><td>+.</td><td>Int a</td><td>Increment (a++)</td></tr>
<tr><td></td><td>+.</td><td>Char a</td><td>Next char (chr(ord(a)+1))</td></tr>
<tr><td></td><td>+.</td><td>Str a<br/>Block a</td><td>Append last of a to a</td></tr>
<tr><td>InfixOf</td><td>~~</td><td>Block a, Block b</td><td>Does a contain b (as a consecutive subsequence)?</td></tr>
<tr><td>Init</td><td>~]</td><td>Block a<br/>Int a</td><td>All except the last element</td></tr>
<tr><td></td><td>~]</td><td>Str a</td><td>All except the last character</td></tr>
<tr><td>InitTail</td><td>~-</td><td>n/a</td><td>Defined as ~][-</td></tr>
<tr><td>Intersection</td><td>IN</td><td>Block a, Block b<br/>Str a,Str b<br/>Int a, Int b</td><td>Intersection</td></tr>
<tr><td>Intersperse</td><td>[[</td><td>Any a, Block b<br/>String a,Char b</td><td>Inserts a between every two element in b</td></tr>
<tr><td>Last</td><td>[~</td><td>Block a<br/>Int a</td><td>Last element of the block</td></tr>
<tr><td>Length</td><td>L[</td><td>Block a</td><td>Length of a</td></tr>
<tr><td></td><td>L[</td><td>Str a</td><td>Length of a</td></tr>
<tr><td></td><td>L[</td><td>Int a</td><td>Convert to char (chr a)</td></tr>
<tr><td></td><td>L[</td><td>Char a</td><td>Return case of a as 'A or 'a</td></tr>
<tr><td>Lines</td><td>ln</td><td>Str a</td><td>Splits a string into lines</td></tr>
<tr><td></td><td>ln</td><td>Int a</td><td>Number of digits in an integer</td></tr>
<tr class="vnext"><td>Log</td><td>lg</td><td>Double a<br/>Int a</td><td>log(a) (natural logarithm)</td></tr>
<tr class="vnext"><td>Log2</td><td>LG</td><td></td><td>Defined as lg\/lg./</td></tr>
<tr><td>Map</td><td>m[</td><td>Block ls, Block f</td><td>Apply f to every element in ls and collect the result in a block</td></tr>
<tr><td></td><td>m[</td><td>Str ls, Block f</td><td>Defined as \/ XX \/ m[ \[</td></tr>
<tr><td>MapDup</td><td>[m</td><td><td>Defined as (^^)+]m[</td></tr>
<tr><td>MapParse</td><td>[m</td><td><td>Defined as (ps)+]m[</td></tr>
<tr><td>MapPretty</td><td>M[</td><td></td><td>Defined as m[ sh</td></tr>
<tr><td>MapToPretty</td><td>M]</td><td></td><td>Defined as {sh}m[</td></tr>
<tr><td>MapToPrettyFromFormat</td><td>m]</td><td></td><td>Defined as {shff}m[</td></tr>
<tr><td>Matches</td><td>~=</td><td>String a, String regex</td><td>1 if regex matches, else 0</td></tr>
<tr><td>MatchesList</td><td>=~</td><td>String a, String regex</td><td>Returns a list of subexpression matches</td></tr>
<tr><td>Max</td><td>&gt;.</td><td>Any a, Any b</td><td>Max(a,b)</td></tr>
<tr><td>Maximum</td><td>&gt;]</td><td>Block a</td><td>Maximum(a)</td></tr>
<tr><td>Min</td><td>&lt;.</td><td>Any a, Any b</td><td>Min(a,b)</td></tr>
<tr><td>Minimum</td><td>&lt;]</td><td>Block a</td><td>Minimum(a)</td></tr>
<tr><td>Mul</td><td>.*</td><td>Int a, Int b</td><td>Regular integer multiplication (a * b)</td></tr>
<tr><td></td><td>.*</td><td>Double a, Double b</td><td>Multiplication (a * b)</td></tr>
<tr><td></td><td>.*</td><td>Str a, Int n</td><td>Returns a block containing n copies of a</td></tr>
<tr><td></td><td>.*</td><td>Char a, Int n</td><td>Returns a string containing n copies of a</td></tr>
<tr><td></td><td>.*</td><td>Block a, Int n</td><td>Returns a block containing n copies of a</td></tr>
<tr><td>Nub</td><td>NB</td><td>Block a<br/>Str a<br/>Int a</td><td>Remove duplicate elements</td></tr>
<tr><td>Not</td><td>n!</td><td>Int a</td><td>Boolish not</td></tr>
<tr><td></td><td>n!</td><td>Block a<br>Str a</td><td>Most common element</td></tr>
<tr class="vnext"><td>NotEqual</td><td>!=</td><td></td><td>Defined as == n!</td></tr>
<tr><td>Or</td><td>||</td><td>Int a, Int b</td><td>Bitwise or</td></tr>
<tr><td>OrLs</td><td>r|</td><td></td><td>Defined as {||}r[</td></tr>
<tr><td>PadLeft</td><td>P[</td><td>Str a, Int c, Char b<br/>Block a, Int c, Any b</td><td>Pad (left) a to length c with b</td></tr>
<tr><td>PadRight</td><td>[P</td><td>Str a, Int c, Char b<br/>Block a, Int c, Any b</td><td>Pad (right) a to length c with b</td></tr>
<tr><td>Parse</td><td>ps</td><td>Str a</td><td>Parses the string as a Burlesque expression and returns a Block</td></tr>
<tr><td>Pop</td><td>vv</td><td></td><td>Remove top most element from the stack</td></tr>
<tr><td>PopSwap</td><td>v/</td><td></td><td>Defined as vv \/</td></tr>
<tr><td>Pow</td><td>**</td><td>Int a, Int b</td><td>Regular integer power (a ^ b)</td></tr>
<tr><td></td><td>**</td><td>Double a, Double b</td><td>Double power (a ** b)</td></tr>
<tr><td></td><td>**</td><td>Block a, Block b</td><td>Merge blocks</td></tr>
<tr><td></td><td>**</td><td>Str a, Str b</td><td>Merge strings</td></tr>
<tr><td></td><td>**</td><td>Char a</td><td>ordinal a. (ord a). </td></tr>
<tr><td>PrefixOf</td><td>~!</td><td>Block a, Block b</td><td>Is b a prefix of a?</td></tr>
<tr><td></td><td>~!</td><td>Int a, Int b</td><td>Is b a prefix of a?</td></tr>
<tr><td></td><td>~!</td><td>Str a, Str b</td><td>Is b a prefix of a?</td></tr>
<tr><td>Pretty</td><td>sh</td><td>Any a</td><td>Convert to pretty type (FormatNormal)</td></tr>
<tr><td>PrettyFormatFromFormat</td><td>SH</td><td>n/a</td><td>Defined as \/ sh \/ Ff</td></tr>
<tr><td>PrettyFromFormat</td><td>Sh</td><td>n/a</td><td>Defined as sh ff</td></tr>
<tr><td>Prepend</td><td>+]</td><td>String a, Char b<br/>Block a,Any b<br/>Int a,Int b</td><td>Prepends b to a</td></tr>
<tr class="vnext"><td>Product</td><td>pd</td><td>Block a</td><td>Defined as {.*}r[</td></tr>
<tr class="vnext"><td></td><td>pd</td><td>Double a</td><td>Ceiling a</td></tr>
<tr class="vnext"><td></td><td>pd</td><td>Int a</td><td>Convert to double</td></tr>
<tr class="vnext"><td>ProductMany</td><td>PD</td><td></td><td>Defined as {pd}m[</td></tr>
<tr><td>PushMany</td><td>^p</td><td>Str a<br>Block a</td><td>Push every element to the stack</td></tr>
<tr><td>PushManyReverse</td><td>p^</td><td>n/a</td><td>Like ^p but in reverse order</td></tr>
<tr><td>Range</td><td>r@</td><td>Int a, Int b</td><td>A block containing natural numbers from a to b (range a b)</td></tr>
<tr><td></td><td>r@</td><td>Char a, Char b</td><td>Same, except for characters</td></tr>
<tr><td></td><td>r@</td><td>Double a</td><td>Square root</td></tr>
<tr><td></td><td>r@</td><td>String a</td><td>All permutations of a</td></tr>
<tr><td></td><td>r@</td><td>Block a</td><td>All permutations of a</td></tr>
<tr><td>RangeInf</td><td>R@</td><td>Int a</td><td>A block containing natural numbers from a to Infinity</td></tr>
<tr><td></td><td>R@</td><td>Str a<br>Block a</td><td>All subsequences of a</td></tr>
<tr><td>ReadInt</td><td>ri</td><td>Int a</td><td>Identity for integers</td></tr>
<tr><td></td><td>ri</td><td>Str a</td><td>Tries to convert a string to an integer</td></tr>
<tr><td></td><td>ri</td><td>Char a</td><td>Is Alpha numeric?<td></tr>
<tr><td>ReadDouble</td><td>rd</td><td>Double a</td><td>Identity for doubles</td></tr>
<tr><td></td><td>rd</td><td>Str a</td><td>Tries to convert a string to an double</td></tr>
<tr><td></td><td>rd</td><td>Char a</td><td>Is Alpha?<td></tr>
<tr><td>ReadArray</td><td>ra</td><td>Str a</td><td>Tries to read an array in [,] notation</td></tr>
<tr><td></td><td>ra</td><td>Char </td><td>Is space?<td></tr>
<tr><td>Reduce</td><td>r[</td><td>Block ls, Block f</td><td>Reduce ls with f</td></tr>
<tr><td>Reverse</td><td>&lt;-</td><td>Int a</td><td>Reverses the digits of the integer</td></tr>
<tr><td></td><td>&lt;-</td><td>Str a</td><td>Reverses the string</td></tr>
<tr><td></td><td>&lt;-</td><td>Block a</td><td>Reverses the block</td></tr>
<tr><td></td><td>&lt;-</td><td>Char a</td><td>Invert case</td></tr>
<tr><td>Replace</td><td>r~</td><td>Block ls, Any old, Any new</td><td>Replaces old in ls with new</td></tr>
<tr><td></td><td>r~</td><td>Str ls, Char old, Char new</td><td>Replaces old in ls with new</td></tr>
<tr><td></td><td>r~</td><td>Str ls, Str old, Str new</td><td>Replaces old in ls with new</td></tr>
<tr><td></td><td>r~</td><td>Int ls, Int old, Int new</td><td>Replaces old in ls with new (digitwise)</td></tr>
<tr><td>ReplaceRegex</td><td>R~</td><td>Str s, Str repl, Str regex</td><td>Regex replace</td></tr>
<tr><td>Round</td><td>r_</td><td>Double a, Int b</td><tD>Round a to b decimal places</td></tr>
<tr><td>Signum</td><td>sn</td><td>Int a<br/>Double a</td><td>Signum a</td></tr>
<tr><td>Smaller</td><td>.&lt;</td><td>Any a, Any b</td><td>Comparision (a &lt; b)</td></tr>
<tr><td>Sort</td><td>&gt;&lt;</td><td>Str a<br/>Block a<br/>Int a</td><td>Sort a</td></tr>
<tr><td></td><td>&gt;&lt;</td><td>Char a</td><td>Is digit?</td></tr>
<tr><td>Split</td><td>;;</td><td>String str, String b</td><td>Split string by b</td></tr>
<tr><td></td><td>;;</td><td>Block ls, Block b</td><td>Split ls by b</td></tr>
<tr><td></td><td>;;</td><td>Int ls, Int b</td><td>Split ls by b</td></tr>
<tr><td>StripLeft</td><td>S[</td><td>Block a, Any b<br/>Str a, Char b</td><td>Strip (left) b from a</td></tr>
<tr><td>StripRight</td><td>[S</td><td>Block a, Any b<br/>Str a, Char b</td><td>Strip (right) b from a</td></tr>
<tr><td>Sub</td><td>.-</td><td>Int a, Int b</td><td>Regular integer subtraction (a - b)</td></tr>
<tr><td></td><td>.-</td><td>Double a, Double b</td><td>Subtraction (a - b)</td></tr>
<tr><td></td><td>.-</td><td>Str a, Str b</td><td>String de-concatenation. If a "endsWith" b, remove b from a.</td></tr>
<tr><td></td><td>.-</td><td>Int b, Str a<br/>Block a, Int b</td><td>Drop b characters from a</td></tr>
<tr><td>SuffixOf</td><td>!~</td><td>Block a, Block b</td><td>Is b a suffix of a?</td></tr>
<tr><td></td><td>!~</td><td>Int a, Int b</td><td>Is b a suffix of a?</td></tr>
<tr><td></td><td>!~</td><td>Str a, Str b</td><td>Is b a suffix of a?</td></tr>
<tr><td>Sum</td><td>++</td><td>Block a</td><td>Defined as {.+}r[</td></tr>
<tr><td></td><td>++</td><td>Int a,Int b</td><td>Concatenate digits.</td></tr>
<tr><td>Swap</td><td>\/</td><td></td><td>Swap elements on top of the stack.</td></tr>
<tr><td>SwapDup</td><td>/^</td><td></td><td>Defined as \/ ^^ </td></tr>
<tr><td>SwapPop</td><td>/v</td><td></td><td>Defined as \/ vv</td></tr>
<tr><td>Tail</td><td>[-</td><td>Block a<br/>Int a</td><td>All except first element.</td></tr>
<tr><td></td><td>[-</td><td>Str a</td><td>All except first character</td></tr>
<tr><td></td><td>[-</td><td>Char a</td><td>Convert to string</td></tr>
<tr><td>ToLower</td><td>zz</td><td>Str a<br/>Char a</td><td>to lower case</td></tr>
<tr><td>ToUpper</td><td>ZZ</td><td>Str a<br/>Char a</td><td>to upper case</td></tr>
<tr><td>TrimLeft</td><td>t[</td><td>Str a</td><td>Trim left</td></tr>
<tr><td>TrimRight</td><td>t]</td><td>Str a</td><td>Trim right</td></tr>
<tr><td>TrimLeftRight</td><td>tt</td><td>Str a</td><td>Defined as t[ t]</td></tr>
<tr><td>Union</td><td>UN</td><td>Block a, Block b<br/>Str a,Str b<br/>Int a, Int b</td><td>Union</td></tr>
<tr><td>Unlines</td><td>un</td><td>n/a</td><td>Defined as "\n" \/ [[ \[</td></tr>
<tr><td>UnlinesPretty</td><td>uN</td><td></td><td>Defined as unsh</td></tr>
<tr><td>Version</td><td>??</td><td></td><td>Version string</td></tr>
<tr><td>Words</td><td>wd</td><td>Str a</td><td>Defined as " ";;</td></tr>
<tr><td></td><td>wd</td><td>Block a</td><td>Defined as ' \/[[\[</td></tr>
<tr><td></td><td>wd</td><td>a</td><td>Defined as \/]]</td></tr>
<tr><td>While</td><td>w!</td><td>Block f, Block p</td><td>While p execute f. (p is expected to leave an Int on top of the stack)
                                                          <br/>Executing p does not affect the global stack.</td></tr>
<tr><td></td><td>w!</td><td>Block f</td><td>Same effect as {f}{}w!</td></tr>
<tr><td>WithLines</td><td>wl</td><td>n/a</td><td>Defined as \/ ln \/ m[ un</td></tr>
<tr><td>WithLinesPretty</td><td>WL</td><td>n/a</td><td>Defined as wl sh</td></tr>
<tr><td>WithLinesParsePretty</td><td>wL</td><td>n/a</td><td>Defined as {ps*}WL (prepends ps to block)</td></tr>
<tr><td>Xor</td><td>$$</td><td>Int a, Int b</td><td>Bitwise xor</td></tr>
<tr><td>Xplode</td><td>XX</td><td>Str a</td><td>Convert a to a block of characters</td></tr>
<tr><td></td><td>XX</td><td>Int a</td><td>Convert a to a block of digits</td></tr>
<tr><td></td><td>XX</td><td>Double a</td><td>Convert a to block containing ceiling a and floor a</td></tr>
<tr><td></td><td>XX</td><td>Char a</td><td>Convert a to a string</td></tr>
<tr><td></td><td>XX</td><td>Block a</td><td>Identity</td></tr>
<tr><td>Zip</td><td>z[</td><td>Block a, Block b<br/>Str a,Str b<br/>Block a, Str b<br/>Str a,Block b</td></td><td>Zips</td></tr>
<tr><td>ZipWith</td><td>Z[</td><td></td><td>Defined as z[m[</td></tr>
</tbody>
</table>
<span style="color: #AA8888;">Since Burlesque 1.7</span>
<!-- -->

      <h1>Syntax</h1>
<pre class="code">
Special :: ","
Double :: { digit }+ , "." , { digit }+
Int :: { digit }+
Char :: "'" , anyChar
String :: "\"" , { anyChar }* , "\""
Block :: "{" , { Expression }* , "}"
Quoted :: "(", ExpressionSingle , ")"
Identifier :: noneOf "1234567890{},' \"" , noneOf "1234567890{},' \""
ExpressionSingle :: { Block | Int | Char | String | Quoted | Identifier }
Expression = { ExpressionSingle }*
</pre>
<h1>Format / Pretty</h1>
<p>
If you write a Burlesque program like <i>"Hello, world!"</i> you will see, that the
output is also <i>"Hello, world!"</i> and not <i>Hello, world!</i>. Stuff is printed
the same way you enter it in code unless you change it to the 'Pretty' type. The <b>sh</b> command
for example does this. <i>"Hello, world!"sh</i> outputs <i>Hello, world!</i>. Keep in mind that
<b>sh</b> changes the type to Pretty, so it's not a string anymore and you can not treat it as a string. A pretty
value can have different formattings and currently the following exist:
<ul>
  <li>0 - normal format</li>
  <li>1 - no spaces</li>
  <li>2 - with spaces</li>
</ul>
<i>{1 2 3}sh1FF</i> is <i>[1,2,3]</i>. <i>{1 2 3}sh0FF</i> is <i>[1, 2, 3]</i>. <i>{1 2 3}sh2FF</i> is
<i>[1 2 3]</i>.
</p>
<h1>Lazy</h1>
<p>
 Burlesque is a lazy programming language which means that it only evaluates stuff that is necessary to evaluate.
 A good example for this is the RangeInf command. <i>1R@"ABCD"z[</i> generates an infinite list 1..Infinity
 and zips it with "ABCD". However, its support for lazyness is limited and does not extend to every command.
</p>
 </body>
</html>
